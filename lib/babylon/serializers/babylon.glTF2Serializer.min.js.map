{"version":3,"file":"babylon.glTF2Serializer.min.js","mappings":"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","sources":["webpack://SERIALIZERS/webpack/universalModuleDefinition","webpack://SERIALIZERS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://SERIALIZERS/webpack/bootstrap","webpack://SERIALIZERS/webpack/runtime/define property getters","webpack://SERIALIZERS/webpack/runtime/global","webpack://SERIALIZERS/webpack/runtime/hasOwnProperty shorthand","webpack://SERIALIZERS/webpack/runtime/make namespace object","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/glTFFileExporter.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFData.ts","webpack://SERIALIZERS/../../../../node_modules/tslib/tslib.es6.mjs","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFAnimation.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFMaterialExporter.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFUtilities.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFExporter.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFSerializer.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_texture_transform.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_lights_punctual.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_sheen.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_unlit.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_ior.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_specular.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_volume.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_transmission.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFExporterExtension.ts","webpack://SERIALIZERS/../../../lts/serializers/src/legacy/legacy-glTF2Serializer.ts","webpack://SERIALIZERS/./src/glTF2.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-serializers\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-serializers\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"SERIALIZERS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__520__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__520__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/** @internal */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var __IGLTFExporterExtension = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for extending the exporter\r\n * @internal\r\n */\r\nexport interface IGLTFExporterExtension {\r\n    /**\r\n     * The name of this extension\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * Defines whether this extension is enabled\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines whether this extension is required\r\n     */\r\n    required: boolean;\r\n}\r\n","import { ImageMimeType } from \"babylonjs-gltf2interface\";\r\n\r\n/**\r\n * Class for holding and downloading glTF file data\r\n */\r\nexport class GLTFData {\r\n    /**\r\n     * Object which contains the file name as the key and its data as the value\r\n     */\r\n    glTFFiles: { [fileName: string]: string | Blob };\r\n\r\n    /**\r\n     * Initializes the glTF file object\r\n     */\r\n    public constructor() {\r\n        this.glTFFiles = {};\r\n    }\r\n\r\n    /**\r\n     * Downloads the glTF data as files based on their names and data\r\n     */\r\n    public downloadFiles(): void {\r\n        /**\r\n         * Checks for a matching suffix at the end of a string (for ES5 and lower)\r\n         * @param str Source string\r\n         * @param suffix Suffix to search for in the source string\r\n         * @returns Boolean indicating whether the suffix was found (true) or not (false)\r\n         */\r\n        function endsWith(str: string, suffix: string): boolean {\r\n            return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n        }\r\n\r\n        for (const key in this.glTFFiles) {\r\n            const link = document.createElement(\"a\");\r\n            document.body.appendChild(link);\r\n            link.setAttribute(\"type\", \"hidden\");\r\n            link.download = key;\r\n            const blob = this.glTFFiles[key];\r\n            let mimeType;\r\n\r\n            if (endsWith(key, \".glb\")) {\r\n                mimeType = { type: \"model/gltf-binary\" };\r\n            } else if (endsWith(key, \".bin\")) {\r\n                mimeType = { type: \"application/octet-stream\" };\r\n            } else if (endsWith(key, \".gltf\")) {\r\n                mimeType = { type: \"model/gltf+json\" };\r\n            } else if (endsWith(key, \".jpeg\") || endsWith(key, \".jpg\")) {\r\n                mimeType = { type: ImageMimeType.JPEG };\r\n            } else if (endsWith(key, \".png\")) {\r\n                mimeType = { type: ImageMimeType.PNG };\r\n            }\r\n\r\n            link.href = window.URL.createObjectURL(new Blob([blob], mimeType));\r\n            link.click();\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n        dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n        dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n};\n","import type { IAnimation, INode, IBufferView, IAccessor, IAnimationSampler, IAnimationChannel } from \"babylonjs-gltf2interface\";\r\nimport { AnimationSamplerInterpolation, AnimationChannelTargetPath, AccessorType, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3, Quaternion } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\n\r\nimport type { _BinaryWriter } from \"./glTFExporter\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\nimport type { IAnimationKey } from \"core/Animations/animationKey\";\r\nimport { AnimationKeyInterpolation } from \"core/Animations/animationKey\";\r\n\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { Light } from \"core/Lights/light\";\r\n\r\n/**\r\n * @internal\r\n * Interface to store animation data.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _IAnimationData {\r\n    /**\r\n     * Keyframe data.\r\n     */\r\n    inputs: number[];\r\n    /**\r\n     * Value data.\r\n     */\r\n    outputs: number[][];\r\n    /**\r\n     * Animation interpolation data.\r\n     */\r\n    samplerInterpolation: AnimationSamplerInterpolation;\r\n    /**\r\n     * Minimum keyframe value.\r\n     */\r\n    inputsMin: number;\r\n    /**\r\n     * Maximum keyframe value.\r\n     */\r\n    inputsMax: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _IAnimationInfo {\r\n    /**\r\n     * The target channel for the animation\r\n     */\r\n    animationChannelTargetPath: AnimationChannelTargetPath;\r\n    /**\r\n     * The glTF accessor type for the data.\r\n     */\r\n    dataAccessorType: AccessorType.VEC3 | AccessorType.VEC4 | AccessorType.SCALAR;\r\n    /**\r\n     * Specifies if quaternions should be used.\r\n     */\r\n    useQuaternion: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Enum for handling in tangent and out tangent.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _TangentType {\r\n    /**\r\n     * Specifies that input tangents are used.\r\n     */\r\n    INTANGENT,\r\n    /**\r\n     * Specifies that output tangents are used.\r\n     */\r\n    OUTTANGENT,\r\n}\r\n\r\n/**\r\n * @internal\r\n * Utility class for generating glTF animation data from BabylonJS.\r\n */\r\nexport class _GLTFAnimation {\r\n    /**\r\n     * Determine if a node is transformable - ie has properties it should be part of animation of transformation.\r\n     * @param babylonNode the node to test\r\n     * @returns true if can be animated, false otherwise. False if the parameter is null or undefined.\r\n     */\r\n    private static _IsTransformable(babylonNode: Node): boolean {\r\n        return babylonNode && (babylonNode instanceof TransformNode || babylonNode instanceof Camera || babylonNode instanceof Light);\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Creates glTF channel animation from BabylonJS animation.\r\n     * @param babylonTransformNode - BabylonJS mesh.\r\n     * @param animation - animation.\r\n     * @param animationChannelTargetPath - The target animation channel.\r\n     * @param useQuaternion - Specifies if quaternions are used.\r\n     * @returns nullable IAnimationData\r\n     */\r\n    public static _CreateNodeAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        useQuaternion: boolean,\r\n        animationSampleRate: number\r\n    ): Nullable<_IAnimationData> {\r\n        if (this._IsTransformable(babylonTransformNode)) {\r\n            const inputs: number[] = [];\r\n            const outputs: number[][] = [];\r\n            const keyFrames = animation.getKeys();\r\n            const minMaxKeyFrames = _GLTFAnimation._CalculateMinMaxKeyFrames(keyFrames);\r\n            const interpolationOrBake = _GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);\r\n\r\n            const interpolation = interpolationOrBake.interpolationType;\r\n            const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;\r\n\r\n            if (shouldBakeAnimation) {\r\n                _GLTFAnimation._CreateBakedAnimation(\r\n                    babylonTransformNode,\r\n                    animation,\r\n                    animationChannelTargetPath,\r\n                    minMaxKeyFrames.min,\r\n                    minMaxKeyFrames.max,\r\n                    animation.framePerSecond,\r\n                    animationSampleRate,\r\n                    inputs,\r\n                    outputs,\r\n                    minMaxKeyFrames,\r\n                    useQuaternion\r\n                );\r\n            } else {\r\n                if (interpolation === AnimationSamplerInterpolation.LINEAR || interpolation === AnimationSamplerInterpolation.STEP) {\r\n                    _GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);\r\n                } else if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                    _GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);\r\n                } else {\r\n                    _GLTFAnimation._CreateBakedAnimation(\r\n                        babylonTransformNode,\r\n                        animation,\r\n                        animationChannelTargetPath,\r\n                        minMaxKeyFrames.min,\r\n                        minMaxKeyFrames.max,\r\n                        animation.framePerSecond,\r\n                        animationSampleRate,\r\n                        inputs,\r\n                        outputs,\r\n                        minMaxKeyFrames,\r\n                        useQuaternion\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (inputs.length && outputs.length) {\r\n                const result: _IAnimationData = {\r\n                    inputs: inputs,\r\n                    outputs: outputs,\r\n                    samplerInterpolation: interpolation,\r\n                    inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),\r\n                    inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond),\r\n                };\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _DeduceAnimationInfo(animation: Animation): Nullable<_IAnimationInfo> {\r\n        let animationChannelTargetPath: Nullable<AnimationChannelTargetPath> = null;\r\n        let dataAccessorType = AccessorType.VEC3;\r\n        let useQuaternion: boolean = false;\r\n        const property = animation.targetProperty.split(\".\");\r\n        switch (property[0]) {\r\n            case \"scaling\": {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.SCALE;\r\n                break;\r\n            }\r\n            case \"position\": {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.TRANSLATION;\r\n                break;\r\n            }\r\n            case \"rotation\": {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case \"rotationQuaternion\": {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                useQuaternion = true;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case \"influence\": {\r\n                dataAccessorType = AccessorType.SCALAR;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.WEIGHTS;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported animatable property ${property[0]}`);\r\n            }\r\n        }\r\n        if (animationChannelTargetPath) {\r\n            return { animationChannelTargetPath: animationChannelTargetPath, dataAccessorType: dataAccessorType, useQuaternion: useQuaternion };\r\n        } else {\r\n            Tools.Error(\"animation channel target path and data accessor type could be deduced\");\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the transform node animations\r\n     * @param babylonNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAnimationFromNodeAnimations(\r\n        babylonNode: Node,\r\n        runtimeGLTFAnimation: IAnimation,\r\n        idleGLTFAnimations: IAnimation[],\r\n        nodeMap: { [key: number]: number },\r\n        nodes: INode[],\r\n        binaryWriter: _BinaryWriter,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        animationSampleRate: number,\r\n        shouldExportAnimation?: (animation: Animation) => boolean\r\n    ) {\r\n        let glTFAnimation: IAnimation;\r\n        if (_GLTFAnimation._IsTransformable(babylonNode)) {\r\n            if (babylonNode.animations) {\r\n                for (const animation of babylonNode.animations) {\r\n                    if (shouldExportAnimation && !shouldExportAnimation(animation)) {\r\n                        continue;\r\n                    }\r\n                    const animationInfo = _GLTFAnimation._DeduceAnimationInfo(animation);\r\n                    if (animationInfo) {\r\n                        glTFAnimation = {\r\n                            name: animation.name,\r\n                            samplers: [],\r\n                            channels: [],\r\n                        };\r\n                        _GLTFAnimation._AddAnimation(\r\n                            `${animation.name}`,\r\n                            animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                            babylonNode,\r\n                            animation,\r\n                            animationInfo.dataAccessorType,\r\n                            animationInfo.animationChannelTargetPath,\r\n                            nodeMap,\r\n                            binaryWriter,\r\n                            bufferViews,\r\n                            accessors,\r\n                            animationInfo.useQuaternion,\r\n                            animationSampleRate\r\n                        );\r\n                        if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                            idleGLTFAnimations.push(glTFAnimation);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create individual morph animations from the mesh's morph target animation tracks\r\n     * @param babylonNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateMorphTargetAnimationFromMorphTargetAnimations(\r\n        babylonNode: Node,\r\n        runtimeGLTFAnimation: IAnimation,\r\n        idleGLTFAnimations: IAnimation[],\r\n        nodeMap: { [key: number]: number },\r\n        nodes: INode[],\r\n        binaryWriter: _BinaryWriter,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        animationSampleRate: number,\r\n        shouldExportAnimation?: (animation: Animation) => boolean\r\n    ) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonNode instanceof Mesh) {\r\n            const morphTargetManager = babylonNode.morphTargetManager;\r\n            if (morphTargetManager) {\r\n                for (let i = 0; i < morphTargetManager.numTargets; ++i) {\r\n                    const morphTarget = morphTargetManager.getTarget(i);\r\n                    for (const animation of morphTarget.animations) {\r\n                        if (shouldExportAnimation && !shouldExportAnimation(animation)) {\r\n                            continue;\r\n                        }\r\n                        const combinedAnimation = new Animation(\r\n                            `${animation.name}`,\r\n                            \"influence\",\r\n                            animation.framePerSecond,\r\n                            animation.dataType,\r\n                            animation.loopMode,\r\n                            animation.enableBlending\r\n                        );\r\n                        const combinedAnimationKeys: IAnimationKey[] = [];\r\n                        const animationKeys = animation.getKeys();\r\n\r\n                        for (let j = 0; j < animationKeys.length; ++j) {\r\n                            const animationKey = animationKeys[j];\r\n                            for (let k = 0; k < morphTargetManager.numTargets; ++k) {\r\n                                if (k == i) {\r\n                                    combinedAnimationKeys.push(animationKey);\r\n                                } else {\r\n                                    combinedAnimationKeys.push({ frame: animationKey.frame, value: 0 });\r\n                                }\r\n                            }\r\n                        }\r\n                        combinedAnimation.setKeys(combinedAnimationKeys);\r\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(combinedAnimation);\r\n                        if (animationInfo) {\r\n                            glTFAnimation = {\r\n                                name: combinedAnimation.name,\r\n                                samplers: [],\r\n                                channels: [],\r\n                            };\r\n                            _GLTFAnimation._AddAnimation(\r\n                                animation.name,\r\n                                animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                                babylonNode,\r\n                                combinedAnimation,\r\n                                animationInfo.dataAccessorType,\r\n                                animationInfo.animationChannelTargetPath,\r\n                                nodeMap,\r\n                                binaryWriter,\r\n                                bufferViews,\r\n                                accessors,\r\n                                animationInfo.useQuaternion,\r\n                                animationSampleRate,\r\n                                morphTargetManager.numTargets\r\n                            );\r\n                            if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                                idleGLTFAnimations.push(glTFAnimation);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node and morph animations from the animation groups\r\n     * @param babylonScene\r\n     * @param glTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAndMorphAnimationFromAnimationGroups(\r\n        babylonScene: Scene,\r\n        glTFAnimations: IAnimation[],\r\n        nodeMap: { [key: number]: number },\r\n        binaryWriter: _BinaryWriter,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        animationSampleRate: number,\r\n        shouldExportAnimation?: (animation: Animation) => boolean\r\n    ) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonScene.animationGroups) {\r\n            const animationGroups = babylonScene.animationGroups;\r\n            for (const animationGroup of animationGroups) {\r\n                const morphAnimations: Map<Mesh, Map<MorphTarget, Animation>> = new Map();\r\n                const sampleAnimations: Map<Mesh, Animation> = new Map();\r\n                const morphAnimationMeshes: Set<Mesh> = new Set();\r\n                const animationGroupFrameDiff = animationGroup.to - animationGroup.from;\r\n                glTFAnimation = {\r\n                    name: animationGroup.name,\r\n                    channels: [],\r\n                    samplers: [],\r\n                };\r\n                for (let i = 0; i < animationGroup.targetedAnimations.length; ++i) {\r\n                    const targetAnimation = animationGroup.targetedAnimations[i];\r\n                    const target = targetAnimation.target;\r\n                    const animation = targetAnimation.animation;\r\n                    if (shouldExportAnimation && !shouldExportAnimation(animation)) {\r\n                        continue;\r\n                    }\r\n                    if (this._IsTransformable(target) || (target.length === 1 && this._IsTransformable(target[0]))) {\r\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            const babylonTransformNode = this._IsTransformable(target) ? target : this._IsTransformable(target[0]) ? target[0] : null;\r\n                            if (babylonTransformNode) {\r\n                                _GLTFAnimation._AddAnimation(\r\n                                    `${animation.name}`,\r\n                                    glTFAnimation,\r\n                                    babylonTransformNode,\r\n                                    animation,\r\n                                    animationInfo.dataAccessorType,\r\n                                    animationInfo.animationChannelTargetPath,\r\n                                    nodeMap,\r\n                                    binaryWriter,\r\n                                    bufferViews,\r\n                                    accessors,\r\n                                    animationInfo.useQuaternion,\r\n                                    animationSampleRate\r\n                                );\r\n                            }\r\n                        }\r\n                    } else if (target instanceof MorphTarget || (target.length === 1 && target[0] instanceof MorphTarget)) {\r\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            const babylonMorphTarget = target instanceof MorphTarget ? (target as MorphTarget) : (target[0] as MorphTarget);\r\n                            if (babylonMorphTarget) {\r\n                                const babylonMorphTargetManager = babylonScene.morphTargetManagers.find((morphTargetManager) => {\r\n                                    for (let j = 0; j < morphTargetManager.numTargets; ++j) {\r\n                                        if (morphTargetManager.getTarget(j) === babylonMorphTarget) {\r\n                                            return true;\r\n                                        }\r\n                                    }\r\n                                    return false;\r\n                                });\r\n                                if (babylonMorphTargetManager) {\r\n                                    const babylonMesh = babylonScene.meshes.find((mesh) => {\r\n                                        return (mesh as Mesh).morphTargetManager === babylonMorphTargetManager;\r\n                                    }) as Mesh;\r\n                                    if (babylonMesh) {\r\n                                        if (!morphAnimations.has(babylonMesh)) {\r\n                                            morphAnimations.set(babylonMesh, new Map());\r\n                                        }\r\n                                        morphAnimations.get(babylonMesh)?.set(babylonMorphTarget, animation);\r\n                                        morphAnimationMeshes.add(babylonMesh);\r\n                                        sampleAnimations.set(babylonMesh, animation);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        // this is the place for the KHR_animation_pointer.\r\n                    }\r\n                }\r\n                morphAnimationMeshes.forEach((mesh) => {\r\n                    const morphTargetManager = mesh.morphTargetManager!;\r\n                    let combinedAnimationGroup: Nullable<Animation> = null;\r\n                    const animationKeys: IAnimationKey[] = [];\r\n                    const sampleAnimation = sampleAnimations.get(mesh)!;\r\n                    const sampleAnimationKeys = sampleAnimation.getKeys();\r\n                    const numAnimationKeys = sampleAnimationKeys.length;\r\n                    /*\r\n                        Due to how glTF expects morph target animation data to be formatted, we need to rearrange the individual morph target animation tracks,\r\n                        such that we have a single animation, where a given keyframe input value has successive output values for each morph target belonging to the manager.\r\n                        See: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n\r\n                        We do this via constructing a new Animation track, and interleaving the frames of each morph target animation track in the current Animation Group\r\n                        We reuse the Babylon Animation data structure for ease of handling export of cubic spline animation keys, and to reuse the\r\n                        existing _GLTFAnimation.AddAnimation codepath with minimal modification, however the constructed Babylon Animation is NOT intended for use in-engine.\r\n                    */\r\n                    for (let i = 0; i < numAnimationKeys; ++i) {\r\n                        for (let j = 0; j < morphTargetManager.numTargets; ++j) {\r\n                            const morphTarget = morphTargetManager.getTarget(j);\r\n                            const animationsByMorphTarget = morphAnimations.get(mesh);\r\n                            if (animationsByMorphTarget) {\r\n                                const morphTargetAnimation = animationsByMorphTarget.get(morphTarget);\r\n                                if (morphTargetAnimation) {\r\n                                    if (!combinedAnimationGroup) {\r\n                                        combinedAnimationGroup = new Animation(\r\n                                            `${animationGroup.name}_${mesh.name}_MorphWeightAnimation`,\r\n                                            \"influence\",\r\n                                            morphTargetAnimation.framePerSecond,\r\n                                            Animation.ANIMATIONTYPE_FLOAT,\r\n                                            morphTargetAnimation.loopMode,\r\n                                            morphTargetAnimation.enableBlending\r\n                                        );\r\n                                    }\r\n                                    animationKeys.push(morphTargetAnimation.getKeys()[i]);\r\n                                } else {\r\n                                    animationKeys.push({\r\n                                        frame: animationGroup.from + (animationGroupFrameDiff / numAnimationKeys) * i,\r\n                                        value: morphTarget.influence,\r\n                                        inTangent: sampleAnimationKeys[0].inTangent ? 0 : undefined,\r\n                                        outTangent: sampleAnimationKeys[0].outTangent ? 0 : undefined,\r\n                                    });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    combinedAnimationGroup!.setKeys(animationKeys);\r\n                    const animationInfo = _GLTFAnimation._DeduceAnimationInfo(combinedAnimationGroup!);\r\n                    if (animationInfo) {\r\n                        _GLTFAnimation._AddAnimation(\r\n                            `${animationGroup.name}_${mesh.name}_MorphWeightAnimation`,\r\n                            glTFAnimation,\r\n                            mesh,\r\n                            combinedAnimationGroup!,\r\n                            animationInfo.dataAccessorType,\r\n                            animationInfo.animationChannelTargetPath,\r\n                            nodeMap,\r\n                            binaryWriter,\r\n                            bufferViews,\r\n                            accessors,\r\n                            animationInfo.useQuaternion,\r\n                            animationSampleRate,\r\n                            morphTargetManager?.numTargets\r\n                        );\r\n                    }\r\n                });\r\n                if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {\r\n                    glTFAnimations.push(glTFAnimation);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _AddAnimation(\r\n        name: string,\r\n        glTFAnimation: IAnimation,\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        dataAccessorType: AccessorType,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        nodeMap: { [key: number]: number },\r\n        binaryWriter: _BinaryWriter,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        useQuaternion: boolean,\r\n        animationSampleRate: number,\r\n        morphAnimationChannels?: number\r\n    ) {\r\n        const animationData = _GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, useQuaternion, animationSampleRate);\r\n        let bufferView: IBufferView;\r\n        let accessor: IAccessor;\r\n        let keyframeAccessorIndex: number;\r\n        let dataAccessorIndex: number;\r\n        let outputLength: number;\r\n        let animationSampler: IAnimationSampler;\r\n        let animationChannel: IAnimationChannel;\r\n\r\n        if (animationData) {\r\n            /*\r\n             * Now that we have the glTF converted morph target animation data,\r\n             * we can remove redundant input data so that we have n input frames,\r\n             * and morphAnimationChannels * n output frames\r\n             */\r\n            if (morphAnimationChannels) {\r\n                let index = 0;\r\n                let currentInput: number = 0;\r\n                const newInputs: number[] = [];\r\n                while (animationData.inputs.length > 0) {\r\n                    currentInput = animationData.inputs.shift()!;\r\n                    if (index % morphAnimationChannels == 0) {\r\n                        newInputs.push(currentInput);\r\n                    }\r\n                    index++;\r\n                }\r\n                animationData.inputs = newInputs;\r\n            }\r\n\r\n            const nodeIndex = nodeMap[babylonTransformNode.uniqueId];\r\n\r\n            // Creates buffer view and accessor for key frames.\r\n            let byteLength = animationData.inputs.length * 4;\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  keyframe data view`);\r\n            bufferViews.push(bufferView);\r\n            animationData.inputs.forEach(function (input) {\r\n                binaryWriter.setFloat32(input);\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(\r\n                bufferViews.length - 1,\r\n                `${name}  keyframes`,\r\n                AccessorType.SCALAR,\r\n                AccessorComponentType.FLOAT,\r\n                animationData.inputs.length,\r\n                null,\r\n                [animationData.inputsMin],\r\n                [animationData.inputsMax]\r\n            );\r\n            accessors.push(accessor);\r\n            keyframeAccessorIndex = accessors.length - 1;\r\n\r\n            // create bufferview and accessor for keyed values.\r\n            outputLength = animationData.outputs.length;\r\n            byteLength = _GLTFUtilities._GetDataAccessorElementCount(dataAccessorType) * 4 * animationData.outputs.length;\r\n\r\n            // check for in and out tangents\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  data view`);\r\n            bufferViews.push(bufferView);\r\n\r\n            animationData.outputs.forEach(function (output) {\r\n                output.forEach(function (entry) {\r\n                    binaryWriter.setFloat32(entry);\r\n                });\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  data`, dataAccessorType, AccessorComponentType.FLOAT, outputLength, null, null, null);\r\n            accessors.push(accessor);\r\n            dataAccessorIndex = accessors.length - 1;\r\n\r\n            // create sampler\r\n            animationSampler = {\r\n                interpolation: animationData.samplerInterpolation,\r\n                input: keyframeAccessorIndex,\r\n                output: dataAccessorIndex,\r\n            };\r\n            glTFAnimation.samplers.push(animationSampler);\r\n\r\n            // create channel\r\n            animationChannel = {\r\n                sampler: glTFAnimation.samplers.length - 1,\r\n                target: {\r\n                    node: nodeIndex,\r\n                    path: animationChannelTargetPath,\r\n                },\r\n            };\r\n            glTFAnimation.channels.push(animationChannel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a baked animation\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation corresponding to the BabylonJS mesh\r\n     * @param animationChannelTargetPath animation target channel\r\n     * @param minFrame minimum animation frame\r\n     * @param maxFrame maximum animation frame\r\n     * @param fps frames per second of the animation\r\n     * @param sampleRate\r\n     * @param inputs input key frames of the animation\r\n     * @param outputs output key frame data of the animation\r\n     * @param minMaxFrames\r\n     * @param minMaxFrames.min\r\n     * @param minMaxFrames.max\r\n     * @param useQuaternion specifies if quaternions should be used\r\n     */\r\n    private static _CreateBakedAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        minFrame: number,\r\n        maxFrame: number,\r\n        fps: number,\r\n        sampleRate: number,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        minMaxFrames: { min: number; max: number },\r\n        useQuaternion: boolean\r\n    ) {\r\n        let value: number | Vector3 | Quaternion;\r\n        const quaternionCache: Quaternion = Quaternion.Identity();\r\n        let previousTime: Nullable<number> = null;\r\n        let time: number;\r\n        let maxUsedFrame: Nullable<number> = null;\r\n        let currKeyFrame: Nullable<IAnimationKey> = null;\r\n        let nextKeyFrame: Nullable<IAnimationKey> = null;\r\n        let prevKeyFrame: Nullable<IAnimationKey> = null;\r\n        let endFrame: Nullable<number> = null;\r\n        minMaxFrames.min = Tools.FloatRound(minFrame / fps);\r\n\r\n        const keyFrames = animation.getKeys();\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            endFrame = null;\r\n            currKeyFrame = keyFrames[i];\r\n\r\n            if (i + 1 < length) {\r\n                nextKeyFrame = keyFrames[i + 1];\r\n                if ((currKeyFrame.value.equals && currKeyFrame.value.equals(nextKeyFrame.value)) || currKeyFrame.value === nextKeyFrame.value) {\r\n                    if (i === 0) {\r\n                        // set the first frame to itself\r\n                        endFrame = currKeyFrame.frame;\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    endFrame = nextKeyFrame.frame;\r\n                }\r\n            } else {\r\n                // at the last key frame\r\n                prevKeyFrame = keyFrames[i - 1];\r\n                if ((currKeyFrame.value.equals && currKeyFrame.value.equals(prevKeyFrame.value)) || currKeyFrame.value === prevKeyFrame.value) {\r\n                    continue;\r\n                } else {\r\n                    endFrame = maxFrame;\r\n                }\r\n            }\r\n            if (endFrame) {\r\n                for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {\r\n                    time = Tools.FloatRound(f / fps);\r\n                    if (time === previousTime) {\r\n                        continue;\r\n                    }\r\n                    previousTime = time;\r\n                    maxUsedFrame = time;\r\n                    const state = {\r\n                        key: 0,\r\n                        repeatCount: 0,\r\n                        loopMode: animation.loopMode,\r\n                    };\r\n                    value = animation._interpolate(f, state);\r\n\r\n                    _GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, useQuaternion);\r\n                }\r\n            }\r\n        }\r\n        if (maxUsedFrame) {\r\n            minMaxFrames.max = maxUsedFrame;\r\n        }\r\n    }\r\n\r\n    private static _ConvertFactorToVector3OrQuaternion(\r\n        factor: number,\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        useQuaternion: boolean\r\n    ): Vector3 | Quaternion {\r\n        const basePositionRotationOrScale = _GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, useQuaternion);\r\n        // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n        const property = animation.targetProperty.split(\".\");\r\n        const componentName = property ? property[1] : \"\"; // x, y, z, or w component\r\n        const value = useQuaternion ? Quaternion.FromArray(basePositionRotationOrScale).normalize() : Vector3.FromArray(basePositionRotationOrScale);\r\n\r\n        switch (componentName) {\r\n            case \"x\":\r\n            case \"y\":\r\n            case \"z\": {\r\n                value[componentName] = factor;\r\n                break;\r\n            }\r\n            case \"w\": {\r\n                (value as Quaternion).w = factor;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`glTFAnimation: Unsupported component name \"${componentName}\"!`);\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    private static _SetInterpolatedValue(\r\n        babylonTransformNode: Node,\r\n        value: number | Vector3 | Quaternion,\r\n        time: number,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        quaternionCache: Quaternion,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        useQuaternion: boolean\r\n    ) {\r\n        let cacheValue: Vector3 | Quaternion | number;\r\n        inputs.push(time);\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.WEIGHTS) {\r\n            outputs.push([value as number]);\r\n            return;\r\n        }\r\n\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_FLOAT) {\r\n            value = this._ConvertFactorToVector3OrQuaternion(value as number, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion);\r\n        }\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                quaternionCache = value as Quaternion;\r\n            } else {\r\n                cacheValue = value as Vector3;\r\n                Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);\r\n            }\r\n            outputs.push(quaternionCache.asArray());\r\n        } else {\r\n            // scaling and position animation\r\n            cacheValue = value as Vector3;\r\n            outputs.push(cacheValue.asArray());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates linear animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateLinearOrStepAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        useQuaternion: boolean\r\n    ) {\r\n        for (const keyFrame of animation.getKeys()) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates cubic spline animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateCubicSplineAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        useQuaternion: boolean\r\n    ) {\r\n        animation.getKeys().forEach(function (keyFrame) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddSplineTangent(_TangentType.INTANGENT, outputs, animationChannelTargetPath, AnimationSamplerInterpolation.CUBICSPLINE, keyFrame, useQuaternion);\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);\r\n\r\n            _GLTFAnimation._AddSplineTangent(_TangentType.OUTTANGENT, outputs, animationChannelTargetPath, AnimationSamplerInterpolation.CUBICSPLINE, keyFrame, useQuaternion);\r\n        });\r\n    }\r\n\r\n    private static _GetBasePositionRotationOrScale(babylonTransformNode: Node, animationChannelTargetPath: AnimationChannelTargetPath, useQuaternion: boolean) {\r\n        let basePositionRotationOrScale: number[];\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                const q = (babylonTransformNode as TransformNode).rotationQuaternion;\r\n                basePositionRotationOrScale = (q ?? Quaternion.Identity()).asArray();\r\n            } else {\r\n                const r: Vector3 = (babylonTransformNode as TransformNode).rotation;\r\n                basePositionRotationOrScale = (r ?? Vector3.Zero()).asArray();\r\n            }\r\n        } else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n            const p: Vector3 = (babylonTransformNode as TransformNode).position;\r\n            basePositionRotationOrScale = (p ?? Vector3.Zero()).asArray();\r\n        } else {\r\n            // scale\r\n            const s: Vector3 = (babylonTransformNode as TransformNode).scaling;\r\n            basePositionRotationOrScale = (s ?? Vector3.One()).asArray();\r\n        }\r\n        return basePositionRotationOrScale;\r\n    }\r\n\r\n    /**\r\n     * Adds a key frame value\r\n     * @param keyFrame\r\n     * @param animation\r\n     * @param outputs\r\n     * @param animationChannelTargetPath\r\n     * @param babylonTransformNode\r\n     * @param useQuaternion\r\n     */\r\n    private static _AddKeyframeValue(\r\n        keyFrame: IAnimationKey,\r\n        animation: Animation,\r\n        outputs: number[][],\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        babylonTransformNode: Node,\r\n        useQuaternion: boolean\r\n    ) {\r\n        let newPositionRotationOrScale: Nullable<Vector3 | Quaternion | number>;\r\n        const animationType = animation.dataType;\r\n        if (animationType === Animation.ANIMATIONTYPE_VECTOR3) {\r\n            let value = keyFrame.value.asArray();\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                const array = Vector3.FromArray(value);\r\n                const rotationQuaternion = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);\r\n                value = rotationQuaternion.asArray();\r\n            }\r\n            outputs.push(value); // scale  vector.\r\n        } else if (animationType === Animation.ANIMATIONTYPE_FLOAT) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.WEIGHTS) {\r\n                outputs.push([keyFrame.value]);\r\n            } else {\r\n                // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n                newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(\r\n                    keyFrame.value as number,\r\n                    babylonTransformNode,\r\n                    animation,\r\n                    animationChannelTargetPath,\r\n                    useQuaternion\r\n                );\r\n                if (newPositionRotationOrScale) {\r\n                    if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                        const posRotScale = useQuaternion\r\n                            ? (newPositionRotationOrScale as Quaternion)\r\n                            : Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();\r\n                        outputs.push(posRotScale.asArray());\r\n                    }\r\n                    outputs.push(newPositionRotationOrScale.asArray());\r\n                }\r\n            }\r\n        } else if (animationType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            outputs.push((keyFrame.value as Quaternion).normalize().asArray());\r\n        } else {\r\n            Tools.Error(\"glTFAnimation: Unsupported key frame values for animation!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine the interpolation based on the key frames\r\n     * @param keyFrames\r\n     * @param animationChannelTargetPath\r\n     * @param useQuaternion\r\n     */\r\n    private static _DeduceInterpolation(\r\n        keyFrames: IAnimationKey[],\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        useQuaternion: boolean\r\n    ): { interpolationType: AnimationSamplerInterpolation; shouldBakeAnimation: boolean } {\r\n        let interpolationType: AnimationSamplerInterpolation | undefined;\r\n        let shouldBakeAnimation = false;\r\n        let key: IAnimationKey;\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION && !useQuaternion) {\r\n            return { interpolationType: AnimationSamplerInterpolation.LINEAR, shouldBakeAnimation: true };\r\n        }\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            key = keyFrames[i];\r\n            if (key.inTangent || key.outTangent) {\r\n                if (interpolationType) {\r\n                    if (interpolationType !== AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    interpolationType = AnimationSamplerInterpolation.CUBICSPLINE;\r\n                }\r\n            } else {\r\n                if (interpolationType) {\r\n                    if (\r\n                        interpolationType === AnimationSamplerInterpolation.CUBICSPLINE ||\r\n                        (key.interpolation && key.interpolation === AnimationKeyInterpolation.STEP && interpolationType !== AnimationSamplerInterpolation.STEP)\r\n                    ) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    if (key.interpolation && key.interpolation === AnimationKeyInterpolation.STEP) {\r\n                        interpolationType = AnimationSamplerInterpolation.STEP;\r\n                    } else {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!interpolationType) {\r\n            interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n        }\r\n\r\n        return { interpolationType: interpolationType, shouldBakeAnimation: shouldBakeAnimation };\r\n    }\r\n\r\n    /**\r\n     * Adds an input tangent or output tangent to the output data\r\n     * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion\r\n     * @param babylonTransformNode\r\n     * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)\r\n     * @param outputs The animation data by keyframe\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param interpolation The interpolation type\r\n     * @param keyFrame The key frame with the animation data\r\n     * @param frameDelta Time difference between two frames used to scale the tangent by the frame delta\r\n     * @param useQuaternion Specifies if quaternions are used\r\n     */\r\n    private static _AddSplineTangent(\r\n        tangentType: _TangentType,\r\n        outputs: number[][],\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        interpolation: AnimationSamplerInterpolation,\r\n        keyFrame: IAnimationKey,\r\n        useQuaternion: boolean\r\n    ) {\r\n        let tangent: number[];\r\n        const tangentValue: Vector3 | Quaternion | number = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;\r\n        if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (tangentValue) {\r\n                    if (useQuaternion) {\r\n                        tangent = (tangentValue as Quaternion).asArray();\r\n                    } else {\r\n                        const array = tangentValue as Vector3;\r\n                        tangent = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();\r\n                    }\r\n                } else {\r\n                    tangent = [0, 0, 0, 0];\r\n                }\r\n            } else if (animationChannelTargetPath === AnimationChannelTargetPath.WEIGHTS) {\r\n                if (tangentValue) {\r\n                    tangent = [tangentValue as number];\r\n                } else {\r\n                    tangent = [0];\r\n                }\r\n            } else {\r\n                if (tangentValue) {\r\n                    tangent = (tangentValue as Vector3).asArray();\r\n                } else {\r\n                    tangent = [0, 0, 0];\r\n                }\r\n            }\r\n\r\n            outputs.push(tangent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the minimum and maximum key frames' frame values\r\n     * @param keyFrames animation key frames\r\n     * @returns the minimum and maximum key frame value\r\n     */\r\n    private static _CalculateMinMaxKeyFrames(keyFrames: IAnimationKey[]): { min: number; max: number } {\r\n        let min: number = Infinity;\r\n        let max: number = -Infinity;\r\n        keyFrames.forEach(function (keyFrame) {\r\n            min = Math.min(min, keyFrame.frame);\r\n            max = Math.max(max, keyFrame.frame);\r\n        });\r\n\r\n        return { min: min, max: max };\r\n    }\r\n}\r\n","import type { ITextureInfo, IMaterial, IMaterialPbrMetallicRoughness, IMaterialOcclusionTextureInfo, ISampler, IMaterialExtension } from \"babylonjs-gltf2interface\";\r\nimport { ImageMimeType, MaterialAlphaMode, TextureMagFilter, TextureMinFilter, TextureWrapMode } from \"babylonjs-gltf2interface\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { TextureTools } from \"core/Misc/textureTools\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport type { _Exporter } from \"./glTFExporter\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { DumpTools } from \"core/Misc/dumpTools\";\r\n\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport type { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ninterface _IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n     */\r\n    diffuseColor: Color3;\r\n    /**\r\n     * Represents the linear specular factors of the material\r\n     */\r\n    specularColor: Color3;\r\n    /**\r\n     * Represents the smoothness of the material\r\n     */\r\n    glossiness: number;\r\n}\r\n\r\n/**\r\n * Interface for storing metallic roughness factors\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ninterface _IPBRMetallicRoughness {\r\n    /**\r\n     * Represents the albedo color of the material\r\n     */\r\n    baseColor: Color3;\r\n    /**\r\n     * Represents the metalness of the material\r\n     */\r\n    metallic: Nullable<number>;\r\n    /**\r\n     * Represents the roughness of the material\r\n     */\r\n    roughness: Nullable<number>;\r\n    /**\r\n     * The metallic roughness texture data\r\n     */\r\n    metallicRoughnessTextureData?: Nullable<ArrayBuffer>;\r\n    /**\r\n     * The base color texture data\r\n     */\r\n    baseColorTextureData?: Nullable<ArrayBuffer>;\r\n}\r\n\r\nfunction getFileExtensionFromMimeType(mimeType: ImageMimeType): string {\r\n    switch (mimeType) {\r\n        case ImageMimeType.JPEG:\r\n            return \".jpg\";\r\n        case ImageMimeType.PNG:\r\n            return \".png\";\r\n        case ImageMimeType.WEBP:\r\n            return \".webp\";\r\n    }\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.  This class should only be used internally\r\n * @internal\r\n */\r\nexport class _GLTFMaterialExporter {\r\n    /**\r\n     * Represents the dielectric specular values for R, G and B\r\n     */\r\n    private static readonly _DielectricSpecular: Color3 = new Color3(0.04, 0.04, 0.04);\r\n\r\n    /**\r\n     * Allows the maximum specular power to be defined for material calculations\r\n     */\r\n    private static readonly _MaxSpecularPower = 1024;\r\n\r\n    /**\r\n     * Mapping to store textures\r\n     */\r\n    private _textureMap: { [textureId: string]: ITextureInfo } = {};\r\n\r\n    // Mapping of internal textures to images to avoid exporting duplicate images.\r\n    private _internalTextureToImage: { [uniqueId: number]: { [mimeType: string]: Promise<number> } } = {};\r\n\r\n    /**\r\n     * Numeric tolerance value\r\n     */\r\n    private static readonly _Epsilon = 1e-6;\r\n\r\n    /**\r\n     * Reference to the glTF Exporter\r\n     */\r\n    private _exporter: _Exporter;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._textureMap = {};\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /**\r\n     * Specifies if two colors are approximately equal in value\r\n     * @param color1 first color to compare to\r\n     * @param color2 second color to compare to\r\n     * @param epsilon threshold value\r\n     */\r\n    private static _FuzzyEquals(color1: Color3, color2: Color3, epsilon: number): boolean {\r\n        return Scalar.WithinEpsilon(color1.r, color2.r, epsilon) && Scalar.WithinEpsilon(color1.g, color2.g, epsilon) && Scalar.WithinEpsilon(color1.b, color2.b, epsilon);\r\n    }\r\n\r\n    /**\r\n     * Gets the materials from a Babylon scene and converts them to glTF materials\r\n     * @param exportMaterials\r\n     * @param mimeType texture mime type\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the material\r\n     */\r\n    public _convertMaterialsToGLTFAsync(exportMaterials: Set<Material>, mimeType: ImageMimeType, hasTextureCoords: boolean) {\r\n        const promises: Promise<IMaterial>[] = [];\r\n        exportMaterials.forEach((material) => {\r\n            if (material.getClassName() === \"StandardMaterial\") {\r\n                promises.push(this._convertStandardMaterialAsync(material as StandardMaterial, mimeType, hasTextureCoords));\r\n            } else if (material.getClassName().indexOf(\"PBR\") !== -1) {\r\n                promises.push(this._convertPBRMaterialAsync(material as PBRMaterial, mimeType, hasTextureCoords));\r\n            } else {\r\n                Tools.Warn(`Unsupported material type: ${material.name}`);\r\n            }\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {\r\n            /* do nothing */\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the glTF material without the texture parameters\r\n     * @param originalMaterial original glTF material\r\n     * @returns glTF material without texture parameters\r\n     */\r\n    public _stripTexturesFromMaterial(originalMaterial: IMaterial): IMaterial {\r\n        const newMaterial: IMaterial = {};\r\n        if (originalMaterial) {\r\n            newMaterial.name = originalMaterial.name;\r\n            newMaterial.doubleSided = originalMaterial.doubleSided;\r\n            newMaterial.alphaMode = originalMaterial.alphaMode;\r\n            newMaterial.alphaCutoff = originalMaterial.alphaCutoff;\r\n            newMaterial.emissiveFactor = originalMaterial.emissiveFactor;\r\n            const originalPBRMetallicRoughness = originalMaterial.pbrMetallicRoughness;\r\n            if (originalPBRMetallicRoughness) {\r\n                newMaterial.pbrMetallicRoughness = {};\r\n                newMaterial.pbrMetallicRoughness.baseColorFactor = originalPBRMetallicRoughness.baseColorFactor;\r\n                newMaterial.pbrMetallicRoughness.metallicFactor = originalPBRMetallicRoughness.metallicFactor;\r\n                newMaterial.pbrMetallicRoughness.roughnessFactor = originalPBRMetallicRoughness.roughnessFactor;\r\n            }\r\n        }\r\n        return newMaterial;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material has any texture parameters present\r\n     * @param material glTF Material\r\n     * @returns boolean specifying if texture parameters are present\r\n     */\r\n    public _hasTexturesPresent(material: IMaterial): boolean {\r\n        if (material.emissiveTexture || material.normalTexture || material.occlusionTexture) {\r\n            return true;\r\n        }\r\n        const pbrMat = material.pbrMetallicRoughness;\r\n        if (pbrMat) {\r\n            if (pbrMat.baseColorTexture || pbrMat.metallicRoughnessTexture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (material.extensions) {\r\n            for (const extension in material.extensions) {\r\n                const extensionObject = material.extensions[extension];\r\n                if (extensionObject as IMaterialExtension) {\r\n                    return extensionObject.hasTextures?.();\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public _getTextureInfo(babylonTexture: Nullable<BaseTexture>): Nullable<ITextureInfo> {\r\n        if (babylonTexture) {\r\n            const textureUid = babylonTexture.uid;\r\n            if (textureUid in this._textureMap) {\r\n                return this._textureMap[textureUid];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon StandardMaterial to a glTF Metallic Roughness Material\r\n     * @param babylonStandardMaterial\r\n     * @returns glTF Metallic Roughness Material representation\r\n     */\r\n    public _convertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n        // Defines a cubic bezier curve where x is specular power and y is roughness\r\n        const P0 = new Vector2(0, 1);\r\n        const P1 = new Vector2(0, 0.1);\r\n        const P2 = new Vector2(0, 0.1);\r\n        const P3 = new Vector2(1300, 0.1);\r\n\r\n        /**\r\n         * Given the control points, solve for x based on a given t for a cubic bezier curve\r\n         * @param t a value between 0 and 1\r\n         * @param p0 first control point\r\n         * @param p1 second control point\r\n         * @param p2 third control point\r\n         * @param p3 fourth control point\r\n         * @returns number result of cubic bezier curve at the specified t\r\n         */\r\n        function cubicBezierCurve(t: number, p0: number, p1: number, p2: number, p3: number): number {\r\n            return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;\r\n        }\r\n\r\n        /**\r\n         * Evaluates a specified specular power value to determine the appropriate roughness value,\r\n         * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)\r\n         * and roughness on the ordinant axis (y-axis)\r\n         * @param specularPower specular power of standard material\r\n         * @returns Number representing the roughness value\r\n         */\r\n        function solveForRoughness(specularPower: number): number {\r\n            // Given P0.x = 0, P1.x = 0, P2.x = 0\r\n            //   x = t * t * t * P3.x\r\n            //   t = (x / P3.x)^(1/3)\r\n            const t = Math.pow(specularPower / P3.x, 0.333333);\r\n            return cubicBezierCurve(t, P0.y, P1.y, P2.y, P3.y);\r\n        }\r\n\r\n        const diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace(babylonStandardMaterial.getScene().getEngine().useExactSrgbConversions).scale(0.5);\r\n        const opacity = babylonStandardMaterial.alpha;\r\n        const specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, _GLTFMaterialExporter._MaxSpecularPower);\r\n\r\n        const roughness = solveForRoughness(specularPower);\r\n\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n            baseColorFactor: [diffuse.r, diffuse.g, diffuse.b, opacity],\r\n            metallicFactor: 0,\r\n            roughnessFactor: roughness,\r\n        };\r\n\r\n        return glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Computes the metallic factor\r\n     * @param diffuse diffused value\r\n     * @param specular specular value\r\n     * @param oneMinusSpecularStrength one minus the specular strength\r\n     * @returns metallic value\r\n     */\r\n    public static _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n        if (specular < this._DielectricSpecular.r) {\r\n            this._DielectricSpecular;\r\n            return 0;\r\n        }\r\n\r\n        const a = this._DielectricSpecular.r;\r\n        const b = (diffuse * oneMinusSpecularStrength) / (1.0 - this._DielectricSpecular.r) + specular - 2.0 * this._DielectricSpecular.r;\r\n        const c = this._DielectricSpecular.r - specular;\r\n        const D = b * b - 4.0 * a * c;\r\n        return Scalar.Clamp((-b + Math.sqrt(D)) / (2.0 * a), 0, 1);\r\n    }\r\n\r\n    /**\r\n     * Sets the glTF alpha mode to a glTF material from the Babylon Material\r\n     * @param glTFMaterial glTF material\r\n     * @param babylonMaterial Babylon material\r\n     */\r\n    private static _SetAlphaMode(glTFMaterial: IMaterial, babylonMaterial: Material & { alphaCutOff: number }): void {\r\n        if (babylonMaterial.needAlphaBlending()) {\r\n            glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n        } else if (babylonMaterial.needAlphaTesting()) {\r\n            glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n            glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon Standard Material to a glTF Material\r\n     * @param babylonStandardMaterial BJS Standard Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        const promises = [];\r\n        const pbrMetallicRoughness = this._convertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const material: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            material.doubleSided = true;\r\n        }\r\n        if (hasTextureCoords) {\r\n            if (babylonStandardMaterial.diffuseTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonStandardMaterial.diffuseTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            pbrMetallicRoughness.baseColorTexture = textureInfo;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            const bumpTexture = babylonStandardMaterial.bumpTexture;\r\n            if (bumpTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(bumpTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            material.normalTexture = textureInfo;\r\n                            if (bumpTexture.level !== 1) {\r\n                                material.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            if (babylonStandardMaterial.emissiveTexture) {\r\n                material.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonStandardMaterial.emissiveTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            material.emissiveTexture = textureInfo;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            if (babylonStandardMaterial.ambientTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonStandardMaterial.ambientTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: textureInfo.index,\r\n                            };\r\n                            material.occlusionTexture = occlusionTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Constants.ALPHA_COMBINE) {\r\n                material.alphaMode = MaterialAlphaMode.BLEND;\r\n            } else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n        if (babylonStandardMaterial.emissiveColor && !_GLTFMaterialExporter._FuzzyEquals(babylonStandardMaterial.emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n            material.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        material.pbrMetallicRoughness = pbrMetallicRoughness;\r\n        _GLTFMaterialExporter._SetAlphaMode(material, babylonStandardMaterial);\r\n\r\n        materials.push(material);\r\n        materialMap[babylonStandardMaterial.uniqueId] = materials.length - 1;\r\n\r\n        return this._finishMaterial(promises, material, babylonStandardMaterial, mimeType);\r\n    }\r\n\r\n    private _finishMaterial<T>(promises: Promise<T>[], glTFMaterial: IMaterial, babylonMaterial: Material, mimeType: ImageMimeType) {\r\n        return Promise.all(promises).then(() => {\r\n            const textures = this._exporter._extensionsPostExportMaterialAdditionalTextures(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n            let tasks: Nullable<Promise<Nullable<ITextureInfo>>[]> = null;\r\n\r\n            for (const texture of textures) {\r\n                if (!tasks) {\r\n                    tasks = [];\r\n                }\r\n                tasks.push(this._exportTextureAsync(texture, mimeType));\r\n            }\r\n\r\n            if (!tasks) {\r\n                tasks = [Promise.resolve(null)];\r\n            }\r\n\r\n            return Promise.all(tasks).then(() => {\r\n                const extensionWork = this._exporter._extensionsPostExportMaterialAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n                if (!extensionWork) {\r\n                    return glTFMaterial;\r\n                }\r\n                return extensionWork.then(() => glTFMaterial);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts an image typed array buffer to a base64 image\r\n     * @param buffer typed array buffer\r\n     * @param width width of the image\r\n     * @param height height of the image\r\n     * @param mimeType mimetype of the image\r\n     * @returns base64 image string\r\n     */\r\n    private async _getImageDataAsync(buffer: Uint8Array | Float32Array, width: number, height: number, mimeType: ImageMimeType): Promise<ArrayBuffer> {\r\n        const textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n\r\n        const hostingScene = this._exporter._babylonScene;\r\n        const engine = hostingScene.getEngine();\r\n\r\n        // Create a temporary texture with the texture buffer data\r\n        const tempTexture = engine.createRawTexture(buffer, width, height, Constants.TEXTUREFORMAT_RGBA, false, true, Texture.NEAREST_SAMPLINGMODE, null, textureType);\r\n\r\n        await TextureTools.ApplyPostProcess(\"pass\", tempTexture, hostingScene, textureType, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTUREFORMAT_RGBA);\r\n\r\n        const data = await engine._readTexturePixels(tempTexture, width, height);\r\n\r\n        return (await DumpTools.DumpDataAsync(width, height, data, mimeType, undefined, true, true)) as ArrayBuffer;\r\n    }\r\n\r\n    /**\r\n     * Generates a white texture based on the specified width and height\r\n     * @param width width of the texture in pixels\r\n     * @param height height of the texture in pixels\r\n     * @param scene babylonjs scene\r\n     * @returns white texture\r\n     */\r\n    private _createWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n        const data = new Uint8Array(width * height * 4);\r\n\r\n        for (let i = 0; i < data.length; i = i + 4) {\r\n            data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xff;\r\n        }\r\n\r\n        const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n        return rawTexture;\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: Nullable<BaseTexture>, texture2: Nullable<BaseTexture>, scene: Scene): { texture1: BaseTexture; texture2: BaseTexture } {\r\n        const texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        const texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1: BaseTexture;\r\n        let resizedTexture2: BaseTexture;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            } else {\r\n                resizedTexture1 = this._createWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2!;\r\n        } else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            } else {\r\n                resizedTexture2 = this._createWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1!;\r\n        } else {\r\n            resizedTexture1 = texture1!;\r\n            resizedTexture2 = texture2!;\r\n        }\r\n\r\n        return {\r\n            texture1: resizedTexture1!,\r\n            texture2: resizedTexture2!,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Converts an array of pixels to a Float32Array\r\n     * Throws an error if the pixel format is not supported\r\n     * @param pixels - array buffer containing pixel values\r\n     * @returns Float32 of pixels\r\n     */\r\n    private _convertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n        if (pixels instanceof Uint8Array) {\r\n            const length = pixels.length;\r\n            const buffer = new Float32Array(pixels.length);\r\n            for (let i = 0; i < length; ++i) {\r\n                buffer[i] = pixels[i] / 255;\r\n            }\r\n            return buffer;\r\n        } else if (pixels instanceof Float32Array) {\r\n            return pixels;\r\n        } else {\r\n            throw new Error(\"Unsupported pixel format!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @link https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(\r\n        diffuseTexture: Nullable<BaseTexture>,\r\n        specularGlossinessTexture: Nullable<BaseTexture>,\r\n        factors: _IPBRSpecularGlossiness,\r\n        mimeType: ImageMimeType\r\n    ): Promise<_IPBRMetallicRoughness> {\r\n        const promises = new Array<Promise<void>>();\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return Promise.reject(\"_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!\");\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            const diffuseSize = resizedTextures.texture1?.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            const diffusePixels = await resizedTextures.texture1.readPixels();\r\n            const specularPixels = await resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = this._convertPixelArrayToFloat32(diffusePixels);\r\n            } else {\r\n                return Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = this._convertPixelArrayToFloat32(specularPixels);\r\n            } else {\r\n                return Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = Color3.Black();\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2])\r\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\r\n                        .multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2])\r\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\r\n                        .multiply(factors.specularColor);\r\n                    const glossiness = specularGlossinessBuffer[offset + 3] * factors.glossiness;\r\n\r\n                    const specularGlossiness: _IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness,\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: _IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness,\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(\r\n                        baseColorBuffer[destinationOffset],\r\n                        baseColorBuffer[destinationOffset + 1],\r\n                        baseColorBuffer[destinationOffset + 2]\r\n                    );\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace(scene.getEngine().useExactSrgbConversions);\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!_GLTFMaterialExporter._FuzzyEquals(sRGBBaseColorPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /=\r\n                        metallicRoughnessFactors.roughness! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > _GLTFMaterialExporter._Epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!_GLTFMaterialExporter._FuzzyEquals(metallicRoughnessPixel, Color3.White(), _GLTFMaterialExporter._Epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                promises.push(\r\n                    this._getImageDataAsync(metallicRoughnessBuffer, width, height, mimeType).then((data) => {\r\n                        metallicRoughnessFactors.metallicRoughnessTextureData = data;\r\n                    })\r\n                );\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                promises.push(\r\n                    this._getImageDataAsync(baseColorBuffer, width, height, mimeType).then((data) => {\r\n                        metallicRoughnessFactors.baseColorTextureData = data;\r\n                    })\r\n                );\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        } else {\r\n            return Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: _IPBRSpecularGlossiness): _IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _GLTFMaterialExporter._SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(\r\n            oneMinusSpecularStrength / (1.0 - _GLTFMaterialExporter._DielectricSpecular.r) / Math.max(1 - metallic, _GLTFMaterialExporter._Epsilon)\r\n        );\r\n        const baseColorFromSpecular = specularGlossiness.specularColor\r\n            .subtract(_GLTFMaterialExporter._DielectricSpecular.scale(1 - metallic))\r\n            .scale(1 / Math.max(metallic, _GLTFMaterialExporter._Epsilon));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness,\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        if (color) {\r\n            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        if (color) {\r\n            return Math.max(color.r, Math.max(color.g, color.b));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertMetalRoughFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        mimeType: ImageMimeType,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasTextureCoords: boolean\r\n    ): Promise<_IPBRMetallicRoughness> {\r\n        const promises = [];\r\n        const baseColor = babylonPBRMaterial._albedoColor;\r\n        const metallic = babylonPBRMaterial._metallic;\r\n        const roughness = babylonPBRMaterial._roughness;\r\n        const metallicRoughness: _IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: roughness,\r\n        };\r\n\r\n        if (hasTextureCoords) {\r\n            const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n            if (albedoTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(babylonPBRMaterial._albedoTexture!, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            const metallicTexture = babylonPBRMaterial._metallicTexture;\r\n            if (metallicTexture) {\r\n                promises.push(\r\n                    this._exportTextureAsync(metallicTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            return metallicRoughness;\r\n        });\r\n    }\r\n\r\n    private _getTextureSampler(texture: Nullable<BaseTexture>): ISampler {\r\n        const sampler: ISampler = {};\r\n        if (!texture || !(texture instanceof Texture)) {\r\n            return sampler;\r\n        }\r\n\r\n        const wrapS = this._getGLTFTextureWrapMode(texture.wrapU);\r\n        if (wrapS !== TextureWrapMode.REPEAT) {\r\n            sampler.wrapS = wrapS;\r\n        }\r\n\r\n        const wrapT = this._getGLTFTextureWrapMode(texture.wrapV);\r\n        if (wrapT !== TextureWrapMode.REPEAT) {\r\n            sampler.wrapT = wrapT;\r\n        }\r\n\r\n        switch (texture.samplingMode) {\r\n            case Texture.LINEAR_LINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private _convertSpecGlossFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        mimeType: ImageMimeType,\r\n        pbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasTextureCoords: boolean\r\n    ): Promise<_IPBRMetallicRoughness> {\r\n        return Promise.resolve().then(() => {\r\n            const specGloss: _IPBRSpecularGlossiness = {\r\n                diffuseColor: babylonPBRMaterial._albedoColor,\r\n                specularColor: babylonPBRMaterial._reflectivityColor,\r\n                glossiness: babylonPBRMaterial._microSurface,\r\n            };\r\n            const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n            const reflectivityTexture = babylonPBRMaterial._reflectivityTexture;\r\n            const useMicrosurfaceFromReflectivityMapAlpha = babylonPBRMaterial._useMicroSurfaceFromReflectivityMapAlpha;\r\n            if (reflectivityTexture && !useMicrosurfaceFromReflectivityMapAlpha) {\r\n                return Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n            }\r\n            if ((albedoTexture || reflectivityTexture) && hasTextureCoords) {\r\n                const samplerIndex = this._exportTextureSampler(albedoTexture || reflectivityTexture);\r\n                return this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(albedoTexture, reflectivityTexture, specGloss, mimeType).then((metallicRoughnessFactors) => {\r\n                    const textures = this._exporter._textures;\r\n                    if (metallicRoughnessFactors.baseColorTextureData) {\r\n                        const imageIndex = this._exportImage(`baseColor${textures.length}`, mimeType, metallicRoughnessFactors.baseColorTextureData);\r\n                        pbrMetallicRoughness.baseColorTexture = this._exportTextureInfo(imageIndex, samplerIndex, albedoTexture?.coordinatesIndex);\r\n                    }\r\n                    if (metallicRoughnessFactors.metallicRoughnessTextureData) {\r\n                        const imageIndex = this._exportImage(`metallicRoughness${textures.length}`, mimeType, metallicRoughnessFactors.metallicRoughnessTextureData);\r\n                        pbrMetallicRoughness.metallicRoughnessTexture = this._exportTextureInfo(imageIndex, samplerIndex, reflectivityTexture?.coordinatesIndex);\r\n                    }\r\n\r\n                    return metallicRoughnessFactors;\r\n                });\r\n            } else {\r\n                return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts a Babylon PBR Base Material to a glTF Material\r\n     * @param babylonPBRMaterial BJS PBR Base Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param hasTextureCoords specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     */\r\n    public _convertPBRMaterialAsync(babylonPBRMaterial: PBRBaseMaterial, mimeType: ImageMimeType, hasTextureCoords: boolean): Promise<IMaterial> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name,\r\n        };\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            const albedoColor = babylonPBRMaterial._albedoColor;\r\n            const alpha = babylonPBRMaterial.alpha;\r\n            if (albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];\r\n            }\r\n            return this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this._setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        } else {\r\n            return this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasTextureCoords).then((metallicRoughness) => {\r\n                return this._setMetallicRoughnessPbrMaterial(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasTextureCoords);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _setMetallicRoughnessPbrMaterial(\r\n        metallicRoughness: Nullable<_IPBRMetallicRoughness>,\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        glTFMaterial: IMaterial,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        mimeType: ImageMimeType,\r\n        hasTextureCoords: boolean\r\n    ): Promise<IMaterial> {\r\n        const materialMap = this._exporter._materialMap;\r\n        const materials = this._exporter._materials;\r\n        const promises = [];\r\n        if (metallicRoughness) {\r\n            _GLTFMaterialExporter._SetAlphaMode(glTFMaterial, babylonPBRMaterial as PBRMaterial);\r\n            if (\r\n                !(\r\n                    _GLTFMaterialExporter._FuzzyEquals(metallicRoughness.baseColor, Color3.White(), _GLTFMaterialExporter._Epsilon) &&\r\n                    babylonPBRMaterial.alpha >= _GLTFMaterialExporter._Epsilon\r\n                )\r\n            ) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [metallicRoughness.baseColor.r, metallicRoughness.baseColor.g, metallicRoughness.baseColor.b, babylonPBRMaterial.alpha];\r\n            }\r\n\r\n            if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n                glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n            }\r\n            if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n                glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n            }\r\n\r\n            if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n                if (!babylonPBRMaterial._twoSidedLighting) {\r\n                    Tools.Warn(babylonPBRMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n                }\r\n                glTFMaterial.doubleSided = true;\r\n            }\r\n\r\n            if (hasTextureCoords) {\r\n                const bumpTexture = babylonPBRMaterial._bumpTexture;\r\n                if (bumpTexture) {\r\n                    const promise = this._exportTextureAsync(bumpTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n                const ambientTexture = babylonPBRMaterial._ambientTexture;\r\n                if (ambientTexture) {\r\n                    const promise = this._exportTextureAsync(ambientTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index,\r\n                                texCoord: glTFTexture.texCoord,\r\n                                extensions: glTFTexture.extensions,\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n                            const ambientTextureStrength = babylonPBRMaterial._ambientTextureStrength;\r\n                            if (ambientTextureStrength) {\r\n                                occlusionTexture.strength = ambientTextureStrength;\r\n                            }\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n                const emissiveTexture = babylonPBRMaterial._emissiveTexture;\r\n                if (emissiveTexture) {\r\n                    const promise = this._exportTextureAsync(emissiveTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    });\r\n                    promises.push(promise);\r\n                }\r\n            }\r\n            const emissiveColor = babylonPBRMaterial._emissiveColor;\r\n            if (!_GLTFMaterialExporter._FuzzyEquals(emissiveColor, Color3.Black(), _GLTFMaterialExporter._Epsilon)) {\r\n                glTFMaterial.emissiveFactor = emissiveColor.asArray();\r\n            }\r\n\r\n            glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n            materials.push(glTFMaterial);\r\n            materialMap[babylonPBRMaterial.uniqueId] = materials.length - 1;\r\n        }\r\n\r\n        return this._finishMaterial(promises, glTFMaterial, babylonPBRMaterial, mimeType);\r\n    }\r\n\r\n    private _getPixelsFromTexture(babylonTexture: BaseTexture): Promise<Nullable<Uint8Array | Float32Array>> {\r\n        const pixels =\r\n            babylonTexture.textureType === Constants.TEXTURETYPE_UNSIGNED_INT\r\n                ? (babylonTexture.readPixels() as Promise<Uint8Array>)\r\n                : (babylonTexture.readPixels() as Promise<Float32Array>);\r\n        return pixels;\r\n    }\r\n\r\n    /**\r\n     * Extracts a texture from a Babylon texture into file data and glTF data\r\n     * @param babylonTexture Babylon texture to extract\r\n     * @param mimeType Mime Type of the babylonTexture\r\n     * @returns glTF texture info, or null if the texture format is not supported\r\n     */\r\n    public _exportTextureAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const extensionPromise = this._exporter._extensionsPreExportTextureAsync(\"exporter\", babylonTexture as Texture, mimeType);\r\n        if (!extensionPromise) {\r\n            return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n        }\r\n\r\n        return extensionPromise.then((texture) => {\r\n            if (!texture) {\r\n                return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n            }\r\n            return this._exportTextureInfoAsync(texture, mimeType);\r\n        });\r\n    }\r\n\r\n    public async _exportTextureInfoAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const textureUid = babylonTexture.uid;\r\n        if (!(textureUid in this._textureMap)) {\r\n            const pixels = await this._getPixelsFromTexture(babylonTexture);\r\n            if (!pixels) {\r\n                return null;\r\n            }\r\n\r\n            const samplerIndex = this._exportTextureSampler(babylonTexture);\r\n\r\n            // Preserve texture mime type if defined\r\n            const textureMimeType = (babylonTexture as Texture).mimeType;\r\n            if (textureMimeType) {\r\n                switch (textureMimeType) {\r\n                    case \"image/jpeg\":\r\n                    case \"image/png\":\r\n                    case \"image/webp\":\r\n                        mimeType = textureMimeType as ImageMimeType;\r\n                        break;\r\n                    default:\r\n                        Tools.Warn(`Unsupported media type: ${textureMimeType}`);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            const internalTextureToImage = this._internalTextureToImage;\r\n            const internalTextureUniqueId = babylonTexture.getInternalTexture()!.uniqueId;\r\n            internalTextureToImage[internalTextureUniqueId] ||= {};\r\n            let imageIndexPromise = internalTextureToImage[internalTextureUniqueId][mimeType];\r\n            if (imageIndexPromise === undefined) {\r\n                const size = babylonTexture.getSize();\r\n                imageIndexPromise = (async () => {\r\n                    const data = await this._getImageDataAsync(pixels, size.width, size.height, mimeType);\r\n                    return this._exportImage(babylonTexture.name, mimeType, data);\r\n                })();\r\n                internalTextureToImage[internalTextureUniqueId][mimeType] = imageIndexPromise;\r\n            }\r\n\r\n            const textureInfo = this._exportTextureInfo(await imageIndexPromise, samplerIndex, babylonTexture.coordinatesIndex);\r\n            this._textureMap[textureUid] = textureInfo;\r\n            this._exporter._extensionsPostExportTextures(\"exporter\", this._textureMap[textureUid], babylonTexture);\r\n        }\r\n\r\n        return this._textureMap[textureUid];\r\n    }\r\n\r\n    private _exportImage(name: string, mimeType: ImageMimeType, data: ArrayBuffer): number {\r\n        const imageData = this._exporter._imageData;\r\n\r\n        const baseName = name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\");\r\n        const extension = getFileExtensionFromMimeType(mimeType);\r\n        let fileName = baseName + extension;\r\n        if (fileName in imageData) {\r\n            fileName = `${baseName}_${Tools.RandomId()}${extension}`;\r\n        }\r\n\r\n        imageData[fileName] = {\r\n            data: data,\r\n            mimeType: mimeType,\r\n        };\r\n\r\n        const images = this._exporter._images;\r\n        images.push({\r\n            name: name,\r\n            uri: fileName,\r\n        });\r\n\r\n        return images.length - 1;\r\n    }\r\n\r\n    private _exportTextureInfo(imageIndex: number, samplerIndex: number, coordinatesIndex?: number): ITextureInfo {\r\n        const textures = this._exporter._textures;\r\n        let textureIndex = textures.findIndex((t) => t.sampler == samplerIndex && t.source === imageIndex);\r\n        if (textureIndex === -1) {\r\n            textureIndex = textures.length;\r\n            textures.push({\r\n                source: imageIndex,\r\n                sampler: samplerIndex,\r\n            });\r\n        }\r\n\r\n        const textureInfo: ITextureInfo = { index: textureIndex };\r\n        if (coordinatesIndex) {\r\n            textureInfo.texCoord = coordinatesIndex;\r\n        }\r\n        return textureInfo;\r\n    }\r\n\r\n    private _exportTextureSampler(texture: Nullable<BaseTexture>): number {\r\n        const sampler = this._getTextureSampler(texture);\r\n\r\n        // if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n        const samplers = this._exporter._samplers;\r\n        const samplerIndex = samplers.findIndex(\r\n            (s) => s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter && s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT\r\n        );\r\n        if (samplerIndex !== -1) {\r\n            return samplerIndex;\r\n        }\r\n\r\n        samplers.push(sampler);\r\n        return samplers.length - 1;\r\n    }\r\n}\r\n","import type { IBufferView, AccessorComponentType, IAccessor } from \"babylonjs-gltf2interface\";\r\nimport { AccessorType } from \"babylonjs-gltf2interface\";\r\n\r\nimport type { FloatArray, Nullable } from \"core/types\";\r\nimport type { Vector4 } from \"core/Maths/math.vector\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class _GLTFUtilities {\r\n    /**\r\n     * Creates a buffer view based on the supplied arguments\r\n     * @param bufferIndex index value of the specified buffer\r\n     * @param byteOffset byte offset value\r\n     * @param byteLength byte length of the bufferView\r\n     * @param byteStride byte distance between conequential elements\r\n     * @param name name of the buffer view\r\n     * @returns bufferView for glTF\r\n     */\r\n    public static _CreateBufferView(bufferIndex: number, byteOffset: number, byteLength: number, byteStride?: number, name?: string): IBufferView {\r\n        const bufferview: IBufferView = { buffer: bufferIndex, byteLength: byteLength };\r\n        if (byteOffset) {\r\n            bufferview.byteOffset = byteOffset;\r\n        }\r\n        if (name) {\r\n            bufferview.name = name;\r\n        }\r\n        if (byteStride) {\r\n            bufferview.byteStride = byteStride;\r\n        }\r\n\r\n        return bufferview;\r\n    }\r\n\r\n    /**\r\n     * Creates an accessor based on the supplied arguments\r\n     * @param bufferviewIndex The index of the bufferview referenced by this accessor\r\n     * @param name The name of the accessor\r\n     * @param type The type of the accessor\r\n     * @param componentType The datatype of components in the attribute\r\n     * @param count The number of attributes referenced by this accessor\r\n     * @param byteOffset The offset relative to the start of the bufferView in bytes\r\n     * @param min Minimum value of each component in this attribute\r\n     * @param max Maximum value of each component in this attribute\r\n     * @returns accessor for glTF\r\n     */\r\n    public static _CreateAccessor(\r\n        bufferviewIndex: number,\r\n        name: string,\r\n        type: AccessorType,\r\n        componentType: AccessorComponentType,\r\n        count: number,\r\n        byteOffset: Nullable<number>,\r\n        min: Nullable<number[]>,\r\n        max: Nullable<number[]>\r\n    ): IAccessor {\r\n        const accessor: IAccessor = { name: name, bufferView: bufferviewIndex, componentType: componentType, count: count, type: type };\r\n\r\n        if (min != null) {\r\n            accessor.min = min;\r\n        }\r\n        if (max != null) {\r\n            accessor.max = max;\r\n        }\r\n        if (byteOffset != null) {\r\n            accessor.byteOffset = byteOffset;\r\n        }\r\n\r\n        return accessor;\r\n    }\r\n\r\n    /**\r\n     * Calculates the minimum and maximum values of an array of position floats\r\n     * @param positions Positions array of a mesh\r\n     * @param vertexStart Starting vertex offset to calculate min and max values\r\n     * @param vertexCount Number of vertices to check for min and max values\r\n     * @returns min number array and max number array\r\n     */\r\n    public static _CalculateMinMaxPositions(positions: FloatArray, vertexStart: number, vertexCount: number): { min: number[]; max: number[] } {\r\n        const min = [Infinity, Infinity, Infinity];\r\n        const max = [-Infinity, -Infinity, -Infinity];\r\n        const positionStrideSize = 3;\r\n        let indexOffset: number;\r\n        let position: Vector3;\r\n        let vector: number[];\r\n\r\n        if (vertexCount) {\r\n            for (let i = vertexStart, length = vertexStart + vertexCount; i < length; ++i) {\r\n                indexOffset = positionStrideSize * i;\r\n\r\n                position = Vector3.FromArray(positions, indexOffset);\r\n                vector = position.asArray();\r\n\r\n                for (let j = 0; j < positionStrideSize; ++j) {\r\n                    const num = vector[j];\r\n                    if (num < min[j]) {\r\n                        min[j] = num;\r\n                    }\r\n                    if (num > max[j]) {\r\n                        max[j] = num;\r\n                    }\r\n                    ++indexOffset;\r\n                }\r\n            }\r\n        }\r\n        return { min, max };\r\n    }\r\n\r\n    public static _NormalizeTangentFromRef(tangent: Vector4) {\r\n        const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);\r\n        if (length > 0) {\r\n            tangent.x /= length;\r\n            tangent.y /= length;\r\n            tangent.z /= length;\r\n        }\r\n    }\r\n\r\n    public static _GetDataAccessorElementCount(accessorType: AccessorType) {\r\n        switch (accessorType) {\r\n            case AccessorType.MAT2:\r\n                return 4;\r\n            case AccessorType.MAT3:\r\n                return 9;\r\n            case AccessorType.MAT4:\r\n                return 16;\r\n            case AccessorType.SCALAR:\r\n                return 1;\r\n            case AccessorType.VEC2:\r\n                return 2;\r\n            case AccessorType.VEC3:\r\n                return 3;\r\n            case AccessorType.VEC4:\r\n                return 4;\r\n        }\r\n    }\r\n}\r\n","import type {\r\n    IBufferView,\r\n    IAccessor,\r\n    INode,\r\n    IScene,\r\n    IMesh,\r\n    IMaterial,\r\n    ITexture,\r\n    IImage,\r\n    ISampler,\r\n    IAnimation,\r\n    IMeshPrimitive,\r\n    IBuffer,\r\n    IGLTF,\r\n    ITextureInfo,\r\n    ISkin,\r\n    ICamera,\r\n} from \"babylonjs-gltf2interface\";\r\nimport { AccessorType, ImageMimeType, MeshPrimitiveMode, AccessorComponentType, CameraType } from \"babylonjs-gltf2interface\";\r\n\r\nimport type { FloatArray, IndicesArray, Nullable } from \"core/types\";\r\nimport { Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Vector2, Vector3, Vector4, Quaternion } from \"core/Maths/math.vector\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Node } from \"core/node\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport { LinesMesh } from \"core/Meshes/linesMesh\";\r\nimport { InstancedMesh } from \"core/Meshes/instancedMesh\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { Engine } from \"core/Engines/engine\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport type { IGLTFExporterExtensionV2 } from \"./glTFExporterExtension\";\r\nimport { _GLTFMaterialExporter } from \"./glTFMaterialExporter\";\r\nimport type { IExportOptions } from \"./glTFSerializer\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport { _GLTFAnimation } from \"./glTFAnimation\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\n\r\n// Matrix that converts handedness on the X-axis.\r\nconst convertHandednessMatrix = Matrix.Compose(new Vector3(-1, 1, 1), Quaternion.Identity(), Vector3.Zero());\r\n\r\nfunction isNoopNode(node: Node, useRightHandedSystem: boolean): boolean {\r\n    if (!(node instanceof TransformNode)) {\r\n        return false;\r\n    }\r\n\r\n    // Transform\r\n    if (useRightHandedSystem) {\r\n        const matrix = node.getWorldMatrix();\r\n        if (!matrix.isIdentity()) {\r\n            return false;\r\n        }\r\n    } else {\r\n        const matrix = node.getWorldMatrix().multiplyToRef(convertHandednessMatrix, TmpVectors.Matrix[0]);\r\n        if (!matrix.isIdentity()) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Geometry\r\n    if ((node instanceof Mesh && node.geometry) || (node instanceof InstancedMesh && node.sourceMesh.geometry)) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction convertNodeHandedness(node: INode): void {\r\n    const translation = Vector3.FromArrayToRef(node.translation || [0, 0, 0], 0, TmpVectors.Vector3[0]);\r\n    const rotation = Quaternion.FromArrayToRef(node.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[0]);\r\n    const scale = Vector3.FromArrayToRef(node.scale || [1, 1, 1], 0, TmpVectors.Vector3[1]);\r\n    const matrix = Matrix.ComposeToRef(scale, rotation, translation, TmpVectors.Matrix[0]).multiplyToRef(convertHandednessMatrix, TmpVectors.Matrix[0]);\r\n\r\n    matrix.decompose(scale, rotation, translation);\r\n\r\n    if (translation.equalsToFloats(0, 0, 0)) {\r\n        delete node.translation;\r\n    } else {\r\n        node.translation = translation.asArray();\r\n    }\r\n\r\n    if (Quaternion.IsIdentity(rotation)) {\r\n        delete node.rotation;\r\n    } else {\r\n        node.rotation = rotation.asArray();\r\n    }\r\n\r\n    if (scale.equalsToFloats(1, 1, 1)) {\r\n        delete node.scale;\r\n    } else {\r\n        node.scale = scale.asArray();\r\n    }\r\n}\r\n\r\n/**\r\n * Utility interface for storing vertex attribute data\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ninterface _IVertexAttributeData {\r\n    /**\r\n     * Specifies the Babylon Vertex Buffer Type (Position, Normal, Color, etc.)\r\n     */\r\n    kind: string;\r\n\r\n    /**\r\n     * Specifies the glTF Accessor Type (VEC2, VEC3, etc.)\r\n     */\r\n    accessorType: AccessorType;\r\n\r\n    /**\r\n     * Specifies the glTF Accessor Component Type (BYTE, UNSIGNED_BYTE, FLOAT, SHORT, INT, etc..)\r\n     */\r\n    accessorComponentType: AccessorComponentType;\r\n\r\n    /**\r\n     * Specifies the BufferView index for the vertex attribute data\r\n     */\r\n    bufferViewIndex?: number;\r\n\r\n    byteStride?: number;\r\n}\r\n/**\r\n * Converts Babylon Scene into glTF 2.0.\r\n * @internal\r\n */\r\nexport class _Exporter {\r\n    /**\r\n     * Stores the glTF to export\r\n     */\r\n    public _glTF: IGLTF;\r\n    /**\r\n     * Stores all generated buffer views, which represents views into the main glTF buffer data\r\n     */\r\n    public _bufferViews: IBufferView[];\r\n    /**\r\n     * Stores all the generated accessors, which is used for accessing the data within the buffer views in glTF\r\n     */\r\n    public _accessors: IAccessor[];\r\n    /**\r\n     * Stores all the generated nodes, which contains transform and/or mesh information per node\r\n     */\r\n    public _nodes: INode[];\r\n    /**\r\n     * Stores all the generated glTF scenes, which stores multiple node hierarchies\r\n     */\r\n    private _scenes: IScene[];\r\n    /**\r\n     * Stores all the generated glTF cameras\r\n     */\r\n    private _cameras: ICamera[];\r\n    /**\r\n     * Stores all the generated mesh information, each containing a set of primitives to render in glTF\r\n     */\r\n    private _meshes: IMesh[];\r\n    /**\r\n     * Stores all the generated material information, which represents the appearance of each primitive\r\n     */\r\n    public _materials: IMaterial[];\r\n\r\n    public _materialMap: { [materialID: number]: number };\r\n    /**\r\n     * Stores all the generated texture information, which is referenced by glTF materials\r\n     */\r\n    public _textures: ITexture[];\r\n    /**\r\n     * Stores all the generated image information, which is referenced by glTF textures\r\n     */\r\n    public _images: IImage[];\r\n\r\n    /**\r\n     * Stores all the texture samplers\r\n     */\r\n    public _samplers: ISampler[];\r\n    /**\r\n     * Stores all the generated glTF skins\r\n     */\r\n    public _skins: ISkin[];\r\n    /**\r\n     * Stores all the generated animation samplers, which is referenced by glTF animations\r\n     */\r\n    /**\r\n     * Stores the animations for glTF models\r\n     */\r\n    private _animations: IAnimation[];\r\n    /**\r\n     * Stores the total amount of bytes stored in the glTF buffer\r\n     */\r\n    private _totalByteLength: number;\r\n    /**\r\n     * Stores a reference to the Babylon scene containing the source geometry and material information\r\n     */\r\n    public _babylonScene: Scene;\r\n    /**\r\n     * Stores a map of the image data, where the key is the file name and the value\r\n     * is the image data\r\n     */\r\n    public _imageData: { [fileName: string]: { data: ArrayBuffer; mimeType: ImageMimeType } };\r\n\r\n    private _orderedImageData: Array<{ data: ArrayBuffer; mimeType: ImageMimeType }>;\r\n\r\n    /**\r\n     * Stores a map of the unique id of a node to its index in the node array\r\n     */\r\n    private _nodeMap: { [key: number]: number };\r\n\r\n    /**\r\n     * Baked animation sample rate\r\n     */\r\n    private _animationSampleRate: number;\r\n\r\n    private _options: IExportOptions;\r\n\r\n    private _localEngine: Engine;\r\n\r\n    public _glTFMaterialExporter: _GLTFMaterialExporter;\r\n\r\n    private _extensions: { [name: string]: IGLTFExporterExtensionV2 } = {};\r\n\r\n    private static _ExtensionNames = new Array<string>();\r\n    private static _ExtensionFactories: { [name: string]: (exporter: _Exporter) => IGLTFExporterExtensionV2 } = {};\r\n\r\n    private _applyExtension<T>(\r\n        node: Nullable<T>,\r\n        extensions: IGLTFExporterExtensionV2[],\r\n        index: number,\r\n        actionAsync: (extension: IGLTFExporterExtensionV2, node: Nullable<T>) => Promise<Nullable<T>> | undefined\r\n    ): Promise<Nullable<T>> {\r\n        if (index >= extensions.length) {\r\n            return Promise.resolve(node);\r\n        }\r\n\r\n        const currentPromise = actionAsync(extensions[index], node);\r\n\r\n        if (!currentPromise) {\r\n            return this._applyExtension(node, extensions, index + 1, actionAsync);\r\n        }\r\n\r\n        return currentPromise.then((newNode) => this._applyExtension(newNode, extensions, index + 1, actionAsync));\r\n    }\r\n\r\n    private _applyExtensions<T>(\r\n        node: Nullable<T>,\r\n        actionAsync: (extension: IGLTFExporterExtensionV2, node: Nullable<T>) => Promise<Nullable<T>> | undefined\r\n    ): Promise<Nullable<T>> {\r\n        const extensions: IGLTFExporterExtensionV2[] = [];\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            extensions.push(this._extensions[name]);\r\n        }\r\n\r\n        return this._applyExtension(node, extensions, 0, actionAsync);\r\n    }\r\n\r\n    public _extensionsPreExportTextureAsync(context: string, babylonTexture: Nullable<Texture>, mimeType: ImageMimeType): Promise<Nullable<BaseTexture>> {\r\n        return this._applyExtensions(babylonTexture, (extension, node) => extension.preExportTextureAsync && extension.preExportTextureAsync(context, node, mimeType));\r\n    }\r\n\r\n    public _extensionsPostExportMeshPrimitiveAsync(\r\n        context: string,\r\n        meshPrimitive: IMeshPrimitive,\r\n        babylonSubMesh: SubMesh,\r\n        binaryWriter: _BinaryWriter\r\n    ): Promise<Nullable<IMeshPrimitive>> {\r\n        return this._applyExtensions(\r\n            meshPrimitive,\r\n            (extension, node) => extension.postExportMeshPrimitiveAsync && extension.postExportMeshPrimitiveAsync(context, node, babylonSubMesh, binaryWriter)\r\n        );\r\n    }\r\n\r\n    public _extensionsPostExportNodeAsync(\r\n        context: string,\r\n        node: Nullable<INode>,\r\n        babylonNode: Node,\r\n        nodeMap: { [key: number]: number },\r\n        binaryWriter: _BinaryWriter\r\n    ): Promise<Nullable<INode>> {\r\n        return this._applyExtensions(node, (extension, node) => extension.postExportNodeAsync && extension.postExportNodeAsync(context, node, babylonNode, nodeMap, binaryWriter));\r\n    }\r\n\r\n    public _extensionsPostExportMaterialAsync(context: string, material: Nullable<IMaterial>, babylonMaterial: Material): Promise<Nullable<IMaterial>> {\r\n        return this._applyExtensions(material, (extension, node) => extension.postExportMaterialAsync && extension.postExportMaterialAsync(context, node, babylonMaterial));\r\n    }\r\n\r\n    public _extensionsPostExportMaterialAdditionalTextures(context: string, material: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const output: BaseTexture[] = [];\r\n\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportMaterialAdditionalTextures) {\r\n                output.push(...extension.postExportMaterialAdditionalTextures(context, material, babylonMaterial));\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    public _extensionsPostExportTextures(context: string, textureInfo: ITextureInfo, babylonTexture: BaseTexture): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportTexture) {\r\n                extension.postExportTexture(context, textureInfo, babylonTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFExporterExtensionV2) => void): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _extensionsOnExporting(): void {\r\n        this._forEachExtensions((extension) => {\r\n            if (extension.wasUsed) {\r\n                if (this._glTF.extensionsUsed == null) {\r\n                    this._glTF.extensionsUsed = [];\r\n                }\r\n\r\n                if (this._glTF.extensionsUsed.indexOf(extension.name) === -1) {\r\n                    this._glTF.extensionsUsed.push(extension.name);\r\n                }\r\n\r\n                if (extension.required) {\r\n                    if (this._glTF.extensionsRequired == null) {\r\n                        this._glTF.extensionsRequired = [];\r\n                    }\r\n                    if (this._glTF.extensionsRequired.indexOf(extension.name) === -1) {\r\n                        this._glTF.extensionsRequired.push(extension.name);\r\n                    }\r\n                }\r\n\r\n                if (this._glTF.extensions == null) {\r\n                    this._glTF.extensions = {};\r\n                }\r\n\r\n                if (extension.onExporting) {\r\n                    extension.onExporting();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load glTF serializer extensions\r\n     */\r\n    private _loadExtensions(): void {\r\n        for (const name of _Exporter._ExtensionNames) {\r\n            const extension = _Exporter._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF Exporter instance, which can accept optional exporter options\r\n     * @param babylonScene Babylon scene object\r\n     * @param options Options to modify the behavior of the exporter\r\n     */\r\n    public constructor(babylonScene?: Nullable<Scene>, options?: IExportOptions) {\r\n        this._glTF = {\r\n            asset: { generator: `Babylon.js v${Engine.Version}`, version: \"2.0\" },\r\n        };\r\n        babylonScene = babylonScene || EngineStore.LastCreatedScene;\r\n        if (!babylonScene) {\r\n            return;\r\n        }\r\n        this._babylonScene = babylonScene;\r\n        this._bufferViews = [];\r\n        this._accessors = [];\r\n        this._meshes = [];\r\n        this._scenes = [];\r\n        this._cameras = [];\r\n        this._nodes = [];\r\n        this._images = [];\r\n        this._materials = [];\r\n        this._materialMap = [];\r\n        this._textures = [];\r\n        this._samplers = [];\r\n        this._skins = [];\r\n        this._animations = [];\r\n        this._imageData = {};\r\n        this._orderedImageData = [];\r\n        this._options = options || {};\r\n        this._animationSampleRate = this._options.animationSampleRate || 1 / 60;\r\n\r\n        this._glTFMaterialExporter = new _GLTFMaterialExporter(this);\r\n        this._loadExtensions();\r\n    }\r\n\r\n    public dispose() {\r\n        for (const extensionKey in this._extensions) {\r\n            const extension = this._extensions[extensionKey];\r\n\r\n            extension.dispose();\r\n        }\r\n    }\r\n\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * Registers a glTF exporter extension\r\n     * @param name Name of the extension to export\r\n     * @param factory The factory function that creates the exporter extension\r\n     */\r\n    public static RegisterExtension(name: string, factory: (exporter: _Exporter) => IGLTFExporterExtensionV2): void {\r\n        if (_Exporter.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name ${name} already exists`);\r\n        }\r\n\r\n        _Exporter._ExtensionFactories[name] = factory;\r\n        _Exporter._ExtensionNames.push(name);\r\n    }\r\n\r\n    /**\r\n     * Un-registers an exporter extension\r\n     * @param name The name fo the exporter extension\r\n     * @returns A boolean indicating whether the extension has been un-registered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!_Exporter._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n        delete _Exporter._ExtensionFactories[name];\r\n\r\n        const index = _Exporter._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            _Exporter._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _reorderIndicesBasedOnPrimitiveMode(submesh: SubMesh, primitiveMode: number, babylonIndices: IndicesArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                if (!byteOffset) {\r\n                    byteOffset = 0;\r\n                }\r\n                for (let i = submesh.indexStart, length = submesh.indexStart + submesh.indexCount; i < length; i = i + 3) {\r\n                    const index = byteOffset + i * 4;\r\n                    // swap the second and third indices\r\n                    const secondIndex = binaryWriter.getUInt32(index + 4);\r\n                    const thirdIndex = binaryWriter.getUInt32(index + 8);\r\n                    binaryWriter.setUInt32(thirdIndex, index + 4);\r\n                    binaryWriter.setUInt32(secondIndex, index + 8);\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                for (let i = submesh.indexStart + submesh.indexCount - 1, start = submesh.indexStart; i >= start; --i) {\r\n                    binaryWriter.setUInt32(babylonIndices[i], byteOffset);\r\n                    byteOffset += 4;\r\n                }\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                if (submesh.indexCount >= 3) {\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 2], byteOffset + 4);\r\n                    binaryWriter.setUInt32(babylonIndices[submesh.indexStart + 1], byteOffset + 8);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attribute data based on the primitive mode.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param primitiveMode Primitive mode of the mesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private _reorderVertexAttributeDataBasedOnPrimitiveMode(\r\n        submesh: SubMesh,\r\n        primitiveMode: number,\r\n        vertexBufferKind: string,\r\n        meshAttributeArray: FloatArray,\r\n        byteOffset: number,\r\n        binaryWriter: _BinaryWriter\r\n    ): void {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                this._reorderTriangleFillMode(submesh, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                this._reorderTriangleStripDrawMode(submesh, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                this._reorderTriangleFanMode(submesh, vertexBufferKind, meshAttributeArray, byteOffset, binaryWriter);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle mode order .  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private _reorderTriangleFillMode(submesh: SubMesh, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this._getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            const stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n            if (submesh.verticesCount % 3 !== 0) {\r\n                Tools.Error(\"The submesh vertices for the triangle fill mode is not divisible by 3!\");\r\n            } else {\r\n                const vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n                let index = 0;\r\n                switch (vertexBufferKind) {\r\n                    case VertexBuffer.PositionKind:\r\n                    case VertexBuffer.NormalKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.TangentKind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.ColorKind: {\r\n                        const size = vertexBuffer.getSize();\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + size) {\r\n                            index = x * stride;\r\n                            if (size === 4) {\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index + stride));\r\n                            } else {\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                                (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VertexBuffer.UVKind:\r\n                    case VertexBuffer.UV2Kind: {\r\n                        for (let x = submesh.verticesStart; x < submesh.verticesStart + submesh.verticesCount; x = x + 3) {\r\n                            index = x * stride;\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + 2 * stride));\r\n                            (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index + stride));\r\n                        }\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                    }\r\n                }\r\n                this._writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, binaryWriter);\r\n            }\r\n        } else {\r\n            Tools.Warn(`reorderTriangleFillMode: Vertex Buffer Kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle strip order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private _reorderTriangleStripDrawMode(submesh: SubMesh, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this._getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            const stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            const vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    index = submesh.verticesStart;\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + 2 * stride));\r\n                    (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index + stride));\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        vertexBuffer.getSize() === 4\r\n                            ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index))\r\n                            : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this._writeVertexAttributeData(vertexData, byteOffset + 12, vertexBufferKind, binaryWriter);\r\n        } else {\r\n            Tools.Warn(`reorderTriangleStripDrawMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reorders the vertex attributes in the correct triangle fan order.  This is necessary when indices are not available and the winding order is\r\n     * clock-wise during export to glTF\r\n     * @param submesh BabylonJS submesh\r\n     * @param vertexBufferKind The type of vertex attribute\r\n     * @param meshAttributeArray The vertex attribute data\r\n     * @param byteOffset The offset to the binary data\r\n     * @param binaryWriter The binary data for the glTF file\r\n     */\r\n    private _reorderTriangleFanMode(submesh: SubMesh, vertexBufferKind: string, meshAttributeArray: FloatArray, byteOffset: number, binaryWriter: _BinaryWriter) {\r\n        const vertexBuffer = this._getVertexBufferFromMesh(vertexBufferKind, submesh.getMesh() as Mesh);\r\n        if (vertexBuffer) {\r\n            const stride = vertexBuffer.byteStride / VertexBuffer.GetTypeByteLength(vertexBuffer.type);\r\n\r\n            const vertexData: Vector2[] | Vector3[] | Vector4[] = [];\r\n            let index = 0;\r\n            switch (vertexBufferKind) {\r\n                case VertexBuffer.PositionKind:\r\n                case VertexBuffer.NormalKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.TangentKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.ColorKind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index));\r\n                        vertexBuffer.getSize() === 4\r\n                            ? (vertexData as Vector4[]).push(Vector4.FromArray(meshAttributeArray, index))\r\n                            : (vertexData as Vector3[]).push(Vector3.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                case VertexBuffer.UVKind:\r\n                case VertexBuffer.UV2Kind: {\r\n                    for (let x = submesh.verticesStart + submesh.verticesCount - 1; x >= submesh.verticesStart; --x) {\r\n                        index = x * stride;\r\n                        (vertexData as Vector2[]).push(Vector2.FromArray(meshAttributeArray, index));\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`Unsupported Vertex Buffer type: ${vertexBufferKind}`);\r\n                }\r\n            }\r\n            this._writeVertexAttributeData(vertexData, byteOffset, vertexBufferKind, binaryWriter);\r\n        } else {\r\n            Tools.Warn(`reorderTriangleFanMode: Vertex buffer kind ${vertexBufferKind} not present!`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes the vertex attribute data to binary\r\n     * @param vertices The vertices to write to the binary writer\r\n     * @param byteOffset The offset into the binary writer to overwrite binary data\r\n     * @param vertexAttributeKind The vertex attribute type\r\n     * @param binaryWriter The writer containing the binary data\r\n     */\r\n    private _writeVertexAttributeData(vertices: Vector2[] | Vector3[] | Vector4[], byteOffset: number, vertexAttributeKind: string, binaryWriter: _BinaryWriter) {\r\n        for (const vertex of vertices) {\r\n            if (vertexAttributeKind === VertexBuffer.NormalKind) {\r\n                vertex.normalize();\r\n            } else if (vertexAttributeKind === VertexBuffer.TangentKind && vertex instanceof Vector4) {\r\n                _GLTFUtilities._NormalizeTangentFromRef(vertex);\r\n            }\r\n\r\n            for (const component of vertex.asArray()) {\r\n                binaryWriter.setFloat32(component, byteOffset);\r\n                byteOffset += 4;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes mesh attribute data to a data buffer\r\n     * Returns the bytelength of the data\r\n     * @param vertexBufferKind Indicates what kind of vertex data is being passed in\r\n     * @param attributeComponentKind\r\n     * @param meshAttributeArray Array containing the attribute data\r\n     * @param stride Specifies the space between data\r\n     * @param binaryWriter The buffer to write the binary data to\r\n     * @param babylonTransformNode\r\n     */\r\n    public _writeAttributeData(\r\n        vertexBufferKind: string,\r\n        attributeComponentKind: AccessorComponentType,\r\n        meshAttributeArray: FloatArray,\r\n        stride: number,\r\n        binaryWriter: _BinaryWriter,\r\n        babylonTransformNode: TransformNode\r\n    ) {\r\n        let vertexAttributes: number[][] = [];\r\n        let index: number;\r\n\r\n        switch (vertexBufferKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.normalize().asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    _GLTFUtilities._NormalizeTangentFromRef(vertexData);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                const meshMaterial = (babylonTransformNode as Mesh).material;\r\n                const convertToLinear = meshMaterial ? meshMaterial.getClassName() === \"StandardMaterial\" : true;\r\n                const vertexData: Color3 | Color4 = stride === 3 ? new Color3() : new Color4();\r\n                const useExactSrgbConversions = this._babylonScene.getEngine().useExactSrgbConversions;\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    if (stride === 3) {\r\n                        Color3.FromArrayToRef(meshAttributeArray, index, vertexData as Color3);\r\n                        if (convertToLinear) {\r\n                            (vertexData as Color3).toLinearSpaceToRef(vertexData as Color3, useExactSrgbConversions);\r\n                        }\r\n                    } else {\r\n                        Color4.FromArrayToRef(meshAttributeArray, index, vertexData as Color4);\r\n                        if (convertToLinear) {\r\n                            (vertexData as Color4).toLinearSpaceToRef(vertexData as Color4, useExactSrgbConversions);\r\n                        }\r\n                    }\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector2.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.MatricesIndicesKind:\r\n            case VertexBuffer.MatricesIndicesExtraKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.MatricesWeightsKind:\r\n            case VertexBuffer.MatricesWeightsExtraKind: {\r\n                for (let k = 0, length = meshAttributeArray.length / stride; k < length; ++k) {\r\n                    index = k * stride;\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    vertexAttributes.push(vertexData.asArray());\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + vertexBufferKind);\r\n                vertexAttributes = [];\r\n            }\r\n        }\r\n\r\n        let writeBinaryFunc;\r\n        switch (attributeComponentKind) {\r\n            case AccessorComponentType.UNSIGNED_BYTE: {\r\n                writeBinaryFunc = binaryWriter.setUInt8.bind(binaryWriter);\r\n                break;\r\n            }\r\n            case AccessorComponentType.UNSIGNED_SHORT: {\r\n                writeBinaryFunc = binaryWriter.setUInt16.bind(binaryWriter);\r\n                break;\r\n            }\r\n            case AccessorComponentType.UNSIGNED_INT: {\r\n                writeBinaryFunc = binaryWriter.setUInt32.bind(binaryWriter);\r\n                break;\r\n            }\r\n            case AccessorComponentType.FLOAT: {\r\n                writeBinaryFunc = binaryWriter.setFloat32.bind(binaryWriter);\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Attribute Component kind: \" + attributeComponentKind);\r\n                return;\r\n            }\r\n        }\r\n\r\n        for (const vertexAttribute of vertexAttributes) {\r\n            for (const component of vertexAttribute) {\r\n                writeBinaryFunc(component);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes mesh attribute data to a data buffer\r\n     * Returns the bytelength of the data\r\n     * @param vertexBufferKind Indicates what kind of vertex data is being passed in\r\n     * @param attributeComponentKind\r\n     * @param meshPrimitive\r\n     * @param morphTarget\r\n     * @param meshAttributeArray Array containing the attribute data\r\n     * @param morphTargetAttributeArray\r\n     * @param stride Specifies the space between data\r\n     * @param binaryWriter The buffer to write the binary data to\r\n     * @param minMax\r\n     */\r\n    public writeMorphTargetAttributeData(\r\n        vertexBufferKind: string,\r\n        attributeComponentKind: AccessorComponentType,\r\n        meshPrimitive: SubMesh,\r\n        meshAttributeArray: FloatArray,\r\n        morphTargetAttributeArray: FloatArray,\r\n        stride: number,\r\n        binaryWriter: _BinaryWriter,\r\n        minMax?: any\r\n    ) {\r\n        let vertexAttributes: number[][] = [];\r\n        let index: number;\r\n        let difference: Vector3 = new Vector3();\r\n        let difference4: Vector4 = new Vector4(0, 0, 0, 0);\r\n\r\n        switch (vertexBufferKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                for (let k = meshPrimitive.verticesStart; k < meshPrimitive.verticesCount; ++k) {\r\n                    index = meshPrimitive.indexStart + k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index);\r\n                    const morphData = Vector3.FromArray(morphTargetAttributeArray, index);\r\n                    difference = morphData.subtractToRef(vertexData, difference);\r\n                    if (minMax) {\r\n                        minMax.min.copyFromFloats(Math.min(difference.x, minMax.min.x), Math.min(difference.y, minMax.min.y), Math.min(difference.z, minMax.min.z));\r\n                        minMax.max.copyFromFloats(Math.max(difference.x, minMax.max.x), Math.max(difference.y, minMax.max.y), Math.max(difference.z, minMax.max.z));\r\n                    }\r\n                    vertexAttributes.push(difference.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                for (let k = meshPrimitive.verticesStart; k < meshPrimitive.verticesCount; ++k) {\r\n                    index = meshPrimitive.indexStart + k * stride;\r\n                    const vertexData = Vector3.FromArray(meshAttributeArray, index).normalize();\r\n                    const morphData = Vector3.FromArray(morphTargetAttributeArray, index).normalize();\r\n                    difference = morphData.subtractToRef(vertexData, difference);\r\n                    vertexAttributes.push(difference.asArray());\r\n                }\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                for (let k = meshPrimitive.verticesStart; k < meshPrimitive.verticesCount; ++k) {\r\n                    index = meshPrimitive.indexStart + k * (stride + 1);\r\n                    const vertexData = Vector4.FromArray(meshAttributeArray, index);\r\n                    _GLTFUtilities._NormalizeTangentFromRef(vertexData);\r\n                    const morphData = Vector4.FromArray(morphTargetAttributeArray, index);\r\n                    _GLTFUtilities._NormalizeTangentFromRef(morphData);\r\n                    difference4 = morphData.subtractToRef(vertexData, difference4);\r\n                    vertexAttributes.push([difference4.x, difference4.y, difference4.z]);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + vertexBufferKind);\r\n                vertexAttributes = [];\r\n            }\r\n        }\r\n\r\n        let writeBinaryFunc;\r\n        switch (attributeComponentKind) {\r\n            case AccessorComponentType.UNSIGNED_BYTE: {\r\n                writeBinaryFunc = binaryWriter.setUInt8.bind(binaryWriter);\r\n                break;\r\n            }\r\n            case AccessorComponentType.UNSIGNED_SHORT: {\r\n                writeBinaryFunc = binaryWriter.setUInt16.bind(binaryWriter);\r\n                break;\r\n            }\r\n            case AccessorComponentType.UNSIGNED_INT: {\r\n                writeBinaryFunc = binaryWriter.setUInt32.bind(binaryWriter);\r\n                break;\r\n            }\r\n            case AccessorComponentType.FLOAT: {\r\n                writeBinaryFunc = binaryWriter.setFloat32.bind(binaryWriter);\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Attribute Component kind: \" + attributeComponentKind);\r\n                return;\r\n            }\r\n        }\r\n\r\n        for (const vertexAttribute of vertexAttributes) {\r\n            for (const component of vertexAttribute) {\r\n                writeBinaryFunc(component);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates glTF json data\r\n     * @param shouldUseGlb Indicates whether the json should be written for a glb file\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @param prettyPrint Indicates whether the json file should be pretty printed (true) or not (false)\r\n     * @returns json data as string\r\n     */\r\n    private _generateJSON(shouldUseGlb: boolean, glTFPrefix?: string, prettyPrint?: boolean): string {\r\n        const buffer: IBuffer = { byteLength: this._totalByteLength };\r\n        let imageName: string;\r\n        let imageData: { data: ArrayBuffer; mimeType: ImageMimeType };\r\n        let bufferView: IBufferView;\r\n        let byteOffset: number = this._totalByteLength;\r\n\r\n        if (buffer.byteLength) {\r\n            this._glTF.buffers = [buffer];\r\n        }\r\n        if (this._nodes && this._nodes.length) {\r\n            this._glTF.nodes = this._nodes;\r\n        }\r\n        if (this._meshes && this._meshes.length) {\r\n            this._glTF.meshes = this._meshes;\r\n        }\r\n        if (this._scenes && this._scenes.length) {\r\n            this._glTF.scenes = this._scenes;\r\n            this._glTF.scene = 0;\r\n        }\r\n        if (this._cameras && this._cameras.length) {\r\n            this._glTF.cameras = this._cameras;\r\n        }\r\n        if (this._bufferViews && this._bufferViews.length) {\r\n            this._glTF.bufferViews = this._bufferViews;\r\n        }\r\n        if (this._accessors && this._accessors.length) {\r\n            this._glTF.accessors = this._accessors;\r\n        }\r\n        if (this._animations && this._animations.length) {\r\n            this._glTF.animations = this._animations;\r\n        }\r\n        if (this._materials && this._materials.length) {\r\n            this._glTF.materials = this._materials;\r\n        }\r\n        if (this._textures && this._textures.length) {\r\n            this._glTF.textures = this._textures;\r\n        }\r\n        if (this._samplers && this._samplers.length) {\r\n            this._glTF.samplers = this._samplers;\r\n        }\r\n        if (this._skins && this._skins.length) {\r\n            this._glTF.skins = this._skins;\r\n        }\r\n        if (this._images && this._images.length) {\r\n            if (!shouldUseGlb) {\r\n                this._glTF.images = this._images;\r\n            } else {\r\n                this._glTF.images = [];\r\n\r\n                this._images.forEach((image) => {\r\n                    if (image.uri) {\r\n                        imageData = this._imageData[image.uri];\r\n                        this._orderedImageData.push(imageData);\r\n                        imageName = image.uri.split(\".\")[0] + \" image\";\r\n                        bufferView = _GLTFUtilities._CreateBufferView(0, byteOffset, imageData.data.byteLength, undefined, imageName);\r\n                        byteOffset += imageData.data.byteLength;\r\n                        this._bufferViews.push(bufferView);\r\n                        image.bufferView = this._bufferViews.length - 1;\r\n                        image.name = imageName;\r\n                        image.mimeType = imageData.mimeType;\r\n                        image.uri = undefined;\r\n                        if (!this._glTF.images) {\r\n                            this._glTF.images = [];\r\n                        }\r\n                        this._glTF.images.push(image);\r\n                    }\r\n                });\r\n                // Replace uri with bufferview and mime type for glb\r\n                buffer.byteLength = byteOffset;\r\n            }\r\n        }\r\n\r\n        if (!shouldUseGlb) {\r\n            buffer.uri = glTFPrefix + \".bin\";\r\n        }\r\n\r\n        const jsonText = prettyPrint ? JSON.stringify(this._glTF, null, 2) : JSON.stringify(this._glTF);\r\n\r\n        return jsonText;\r\n    }\r\n\r\n    /**\r\n     * Generates data for .gltf and .bin files based on the glTF prefix string\r\n     * @param glTFPrefix Text to use when prefixing a glTF file\r\n     * @param dispose Dispose the exporter\r\n     * @returns GLTFData with glTF file data\r\n     */\r\n    public _generateGLTFAsync(glTFPrefix: string, dispose = true): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            this._extensionsOnExporting();\r\n            const jsonText = this._generateJSON(false, glTFPrefix, true);\r\n            const bin = new Blob([binaryBuffer], { type: \"application/octet-stream\" });\r\n\r\n            const glTFFileName = glTFPrefix + \".gltf\";\r\n            const glTFBinFile = glTFPrefix + \".bin\";\r\n\r\n            const container = new GLTFData();\r\n\r\n            container.glTFFiles[glTFFileName] = jsonText;\r\n            container.glTFFiles[glTFBinFile] = bin;\r\n\r\n            if (this._imageData) {\r\n                for (const image in this._imageData) {\r\n                    container.glTFFiles[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });\r\n                }\r\n            }\r\n\r\n            if (dispose) {\r\n                this.dispose();\r\n            }\r\n\r\n            return container;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a binary buffer for glTF\r\n     * @returns array buffer for binary data\r\n     */\r\n    private _generateBinaryAsync(): Promise<ArrayBuffer> {\r\n        const binaryWriter = new _BinaryWriter(4);\r\n        return this._createSceneAsync(binaryWriter).then(() => {\r\n            if (this._localEngine) {\r\n                this._localEngine.dispose();\r\n            }\r\n            return binaryWriter.getArrayBuffer();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Pads the number to a multiple of 4\r\n     * @param num number to pad\r\n     * @returns padded number\r\n     */\r\n    private _getPadding(num: number): number {\r\n        const remainder = num % 4;\r\n        const padding = remainder === 0 ? remainder : 4 - remainder;\r\n\r\n        return padding;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _generateGLBAsync(glTFPrefix: string, dispose = true): Promise<GLTFData> {\r\n        return this._generateBinaryAsync().then((binaryBuffer) => {\r\n            this._extensionsOnExporting();\r\n            const jsonText = this._generateJSON(true);\r\n            const glbFileName = glTFPrefix + \".glb\";\r\n            const headerLength = 12;\r\n            const chunkLengthPrefix = 8;\r\n            let jsonLength = jsonText.length;\r\n            let encodedJsonText;\r\n            let imageByteLength = 0;\r\n            // make use of TextEncoder when available\r\n            if (typeof TextEncoder !== \"undefined\") {\r\n                const encoder = new TextEncoder();\r\n                encodedJsonText = encoder.encode(jsonText);\r\n                jsonLength = encodedJsonText.length;\r\n            }\r\n            for (let i = 0; i < this._orderedImageData.length; ++i) {\r\n                imageByteLength += this._orderedImageData[i].data.byteLength;\r\n            }\r\n            const jsonPadding = this._getPadding(jsonLength);\r\n            const binPadding = this._getPadding(binaryBuffer.byteLength);\r\n            const imagePadding = this._getPadding(imageByteLength);\r\n\r\n            const byteLength = headerLength + 2 * chunkLengthPrefix + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding + imageByteLength + imagePadding;\r\n\r\n            //header\r\n            const headerBuffer = new ArrayBuffer(headerLength);\r\n            const headerBufferView = new DataView(headerBuffer);\r\n            headerBufferView.setUint32(0, 0x46546c67, true); //glTF\r\n            headerBufferView.setUint32(4, 2, true); // version\r\n            headerBufferView.setUint32(8, byteLength, true); // total bytes in file\r\n\r\n            //json chunk\r\n            const jsonChunkBuffer = new ArrayBuffer(chunkLengthPrefix + jsonLength + jsonPadding);\r\n            const jsonChunkBufferView = new DataView(jsonChunkBuffer);\r\n            jsonChunkBufferView.setUint32(0, jsonLength + jsonPadding, true);\r\n            jsonChunkBufferView.setUint32(4, 0x4e4f534a, true);\r\n\r\n            //json chunk bytes\r\n            const jsonData = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix);\r\n            // if TextEncoder was available, we can simply copy the encoded array\r\n            if (encodedJsonText) {\r\n                jsonData.set(encodedJsonText);\r\n            } else {\r\n                const blankCharCode = \"_\".charCodeAt(0);\r\n                for (let i = 0; i < jsonLength; ++i) {\r\n                    const charCode = jsonText.charCodeAt(i);\r\n                    // if the character doesn't fit into a single UTF-16 code unit, just put a blank character\r\n                    if (charCode != jsonText.codePointAt(i)) {\r\n                        jsonData[i] = blankCharCode;\r\n                    } else {\r\n                        jsonData[i] = charCode;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //json padding\r\n            const jsonPaddingView = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix + jsonLength);\r\n            for (let i = 0; i < jsonPadding; ++i) {\r\n                jsonPaddingView[i] = 0x20;\r\n            }\r\n\r\n            //binary chunk\r\n            const binaryChunkBuffer = new ArrayBuffer(chunkLengthPrefix);\r\n            const binaryChunkBufferView = new DataView(binaryChunkBuffer);\r\n            binaryChunkBufferView.setUint32(0, binaryBuffer.byteLength + imageByteLength + imagePadding, true);\r\n            binaryChunkBufferView.setUint32(4, 0x004e4942, true);\r\n\r\n            // binary padding\r\n            const binPaddingBuffer = new ArrayBuffer(binPadding);\r\n            const binPaddingView = new Uint8Array(binPaddingBuffer);\r\n            for (let i = 0; i < binPadding; ++i) {\r\n                binPaddingView[i] = 0;\r\n            }\r\n\r\n            const imagePaddingBuffer = new ArrayBuffer(imagePadding);\r\n            const imagePaddingView = new Uint8Array(imagePaddingBuffer);\r\n            for (let i = 0; i < imagePadding; ++i) {\r\n                imagePaddingView[i] = 0;\r\n            }\r\n\r\n            const glbData = [headerBuffer, jsonChunkBuffer, binaryChunkBuffer, binaryBuffer];\r\n\r\n            // binary data\r\n            for (let i = 0; i < this._orderedImageData.length; ++i) {\r\n                glbData.push(this._orderedImageData[i].data);\r\n            }\r\n\r\n            glbData.push(binPaddingBuffer);\r\n\r\n            glbData.push(imagePaddingBuffer);\r\n\r\n            const glbFile = new Blob(glbData, { type: \"application/octet-stream\" });\r\n\r\n            const container = new GLTFData();\r\n            container.glTFFiles[glbFileName] = glbFile;\r\n\r\n            if (this._localEngine != null) {\r\n                this._localEngine.dispose();\r\n            }\r\n\r\n            if (dispose) {\r\n                this.dispose();\r\n            }\r\n\r\n            return container;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the TRS for each node\r\n     * @param node glTF Node for storing the transformation data\r\n     * @param babylonTransformNode Babylon mesh used as the source for the transformation data\r\n     */\r\n    private _setNodeTransformation(node: INode, babylonTransformNode: TransformNode): void {\r\n        if (!babylonTransformNode.getPivotPoint().equalsToFloats(0, 0, 0)) {\r\n            Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\r\n        }\r\n        if (!babylonTransformNode.position.equalsToFloats(0, 0, 0)) {\r\n            node.translation = babylonTransformNode.position.asArray();\r\n        }\r\n\r\n        if (!babylonTransformNode.scaling.equalsToFloats(1, 1, 1)) {\r\n            node.scale = babylonTransformNode.scaling.asArray();\r\n        }\r\n\r\n        const rotationQuaternion = Quaternion.RotationYawPitchRoll(babylonTransformNode.rotation.y, babylonTransformNode.rotation.x, babylonTransformNode.rotation.z);\r\n        if (babylonTransformNode.rotationQuaternion) {\r\n            rotationQuaternion.multiplyInPlace(babylonTransformNode.rotationQuaternion);\r\n        }\r\n        if (!Quaternion.IsIdentity(rotationQuaternion)) {\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private _setCameraTransformation(node: INode, babylonCamera: Camera): void {\r\n        if (!babylonCamera.position.equalsToFloats(0, 0, 0)) {\r\n            node.translation = babylonCamera.position.asArray();\r\n        }\r\n\r\n        const rotationQuaternion = (<any>babylonCamera).rotationQuaternion; // we target the local transformation if one.\r\n\r\n        if (rotationQuaternion && !Quaternion.IsIdentity(rotationQuaternion)) {\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private _getVertexBufferFromMesh(attributeKind: string, bufferMesh: Mesh): Nullable<VertexBuffer> {\r\n        if (bufferMesh.isVerticesDataPresent(attributeKind, true)) {\r\n            const vertexBuffer = bufferMesh.getVertexBuffer(attributeKind, true);\r\n            if (vertexBuffer) {\r\n                return vertexBuffer;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a bufferview based on the vertices type for the Babylon mesh\r\n     * @param kind Indicates the type of vertices data\r\n     * @param attributeComponentKind Indicates the numerical type used to store the data\r\n     * @param babylonTransformNode The Babylon mesh to get the vertices data from\r\n     * @param binaryWriter The buffer to write the bufferview data to\r\n     * @param byteStride\r\n     */\r\n    private _createBufferViewKind(\r\n        kind: string,\r\n        attributeComponentKind: AccessorComponentType,\r\n        babylonTransformNode: TransformNode,\r\n        binaryWriter: _BinaryWriter,\r\n        byteStride: number\r\n    ) {\r\n        const bufferMesh =\r\n            babylonTransformNode instanceof Mesh\r\n                ? (babylonTransformNode as Mesh)\r\n                : babylonTransformNode instanceof InstancedMesh\r\n                  ? (babylonTransformNode as InstancedMesh).sourceMesh\r\n                  : null;\r\n\r\n        if (bufferMesh) {\r\n            const vertexBuffer = bufferMesh.getVertexBuffer(kind, true);\r\n            const vertexData = bufferMesh.getVerticesData(kind, undefined, undefined, true);\r\n\r\n            if (vertexBuffer && vertexData) {\r\n                const typeByteLength = VertexBuffer.GetTypeByteLength(attributeComponentKind);\r\n                const byteLength = vertexData.length * typeByteLength;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, kind + \" - \" + bufferMesh.name);\r\n                this._bufferViews.push(bufferView);\r\n\r\n                this._writeAttributeData(kind, attributeComponentKind, vertexData, byteStride / typeByteLength, binaryWriter, babylonTransformNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a bufferview based on the vertices type for the Babylon mesh\r\n     * @param babylonSubMesh The Babylon submesh that the morph target is applied to\r\n     * @param meshPrimitive\r\n     * @param babylonMorphTarget the morph target to be exported\r\n     * @param binaryWriter The buffer to write the bufferview data to\r\n     */\r\n    private _setMorphTargetAttributes(babylonSubMesh: SubMesh, meshPrimitive: IMeshPrimitive, babylonMorphTarget: MorphTarget, binaryWriter: _BinaryWriter) {\r\n        if (babylonMorphTarget) {\r\n            if (!meshPrimitive.targets) {\r\n                meshPrimitive.targets = [];\r\n            }\r\n            const target: { [attribute: string]: number } = {};\r\n            const mesh = babylonSubMesh.getMesh() as Mesh;\r\n            if (babylonMorphTarget.hasNormals) {\r\n                const vertexNormals = mesh.getVerticesData(VertexBuffer.NormalKind, undefined, undefined, true)!;\r\n                const morphNormals = babylonMorphTarget.getNormals()!;\r\n                const count = babylonSubMesh.verticesCount;\r\n                const byteStride = 12; // 3 x 4 byte floats\r\n                const byteLength = count * byteStride;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, babylonMorphTarget.name + \"_NORMAL\");\r\n                this._bufferViews.push(bufferView);\r\n\r\n                const bufferViewIndex = this._bufferViews.length - 1;\r\n                const accessor = _GLTFUtilities._CreateAccessor(\r\n                    bufferViewIndex,\r\n                    babylonMorphTarget.name + \" - \" + \"NORMAL\",\r\n                    AccessorType.VEC3,\r\n                    AccessorComponentType.FLOAT,\r\n                    count,\r\n                    0,\r\n                    null,\r\n                    null\r\n                );\r\n                this._accessors.push(accessor);\r\n                target.NORMAL = this._accessors.length - 1;\r\n\r\n                this.writeMorphTargetAttributeData(VertexBuffer.NormalKind, AccessorComponentType.FLOAT, babylonSubMesh, vertexNormals, morphNormals, byteStride / 4, binaryWriter);\r\n            }\r\n            if (babylonMorphTarget.hasPositions) {\r\n                const vertexPositions = mesh.getVerticesData(VertexBuffer.PositionKind, undefined, undefined, true)!;\r\n                const morphPositions = babylonMorphTarget.getPositions()!;\r\n                const count = babylonSubMesh.verticesCount;\r\n                const byteStride = 12; // 3 x 4 byte floats\r\n                const byteLength = count * byteStride;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, babylonMorphTarget.name + \"_POSITION\");\r\n                this._bufferViews.push(bufferView);\r\n\r\n                const bufferViewIndex = this._bufferViews.length - 1;\r\n                const minMax = { min: new Vector3(Infinity, Infinity, Infinity), max: new Vector3(-Infinity, -Infinity, -Infinity) };\r\n                const accessor = _GLTFUtilities._CreateAccessor(\r\n                    bufferViewIndex,\r\n                    babylonMorphTarget.name + \" - \" + \"POSITION\",\r\n                    AccessorType.VEC3,\r\n                    AccessorComponentType.FLOAT,\r\n                    count,\r\n                    0,\r\n                    null,\r\n                    null\r\n                );\r\n                this._accessors.push(accessor);\r\n                target.POSITION = this._accessors.length - 1;\r\n\r\n                this.writeMorphTargetAttributeData(\r\n                    VertexBuffer.PositionKind,\r\n                    AccessorComponentType.FLOAT,\r\n                    babylonSubMesh,\r\n                    vertexPositions,\r\n                    morphPositions,\r\n                    byteStride / 4,\r\n                    binaryWriter,\r\n                    minMax\r\n                );\r\n                accessor.min = minMax.min!.asArray();\r\n                accessor.max = minMax.max!.asArray();\r\n            }\r\n            if (babylonMorphTarget.hasTangents) {\r\n                const vertexTangents = mesh.getVerticesData(VertexBuffer.TangentKind, undefined, undefined, true)!;\r\n                const morphTangents = babylonMorphTarget.getTangents()!;\r\n                const count = babylonSubMesh.verticesCount;\r\n                const byteStride = 12; // 3 x 4 byte floats\r\n                const byteLength = count * byteStride;\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, byteStride, babylonMorphTarget.name + \"_NORMAL\");\r\n                this._bufferViews.push(bufferView);\r\n\r\n                const bufferViewIndex = this._bufferViews.length - 1;\r\n                const accessor = _GLTFUtilities._CreateAccessor(\r\n                    bufferViewIndex,\r\n                    babylonMorphTarget.name + \" - \" + \"TANGENT\",\r\n                    AccessorType.VEC3,\r\n                    AccessorComponentType.FLOAT,\r\n                    count,\r\n                    0,\r\n                    null,\r\n                    null\r\n                );\r\n                this._accessors.push(accessor);\r\n                target.TANGENT = this._accessors.length - 1;\r\n\r\n                this.writeMorphTargetAttributeData(\r\n                    VertexBuffer.TangentKind,\r\n                    AccessorComponentType.FLOAT,\r\n                    babylonSubMesh,\r\n                    vertexTangents,\r\n                    morphTangents,\r\n                    byteStride / 4,\r\n                    binaryWriter\r\n                );\r\n            }\r\n            meshPrimitive.targets.push(target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The primitive mode of the Babylon mesh\r\n     * @param babylonMesh The BabylonJS mesh\r\n     */\r\n    private _getMeshPrimitiveMode(babylonMesh: AbstractMesh): number {\r\n        if (babylonMesh instanceof LinesMesh) {\r\n            return Material.LineListDrawMode;\r\n        }\r\n        if (babylonMesh instanceof InstancedMesh || babylonMesh instanceof Mesh) {\r\n            const baseMesh = babylonMesh instanceof Mesh ? babylonMesh : babylonMesh.sourceMesh;\r\n            if (typeof baseMesh.overrideRenderingFillMode === \"number\") {\r\n                return baseMesh.overrideRenderingFillMode;\r\n            }\r\n        }\r\n        return babylonMesh.material ? babylonMesh.material.fillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the primitive mode of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param primitiveMode The primitive mode\r\n     */\r\n    private _setPrimitiveMode(meshPrimitive: IMeshPrimitive, primitiveMode: number) {\r\n        switch (primitiveMode) {\r\n            case Material.TriangleFillMode: {\r\n                // glTF defaults to using Triangle Mode\r\n                break;\r\n            }\r\n            case Material.TriangleStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_STRIP;\r\n                break;\r\n            }\r\n            case Material.TriangleFanDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.TRIANGLE_FAN;\r\n                break;\r\n            }\r\n            case Material.PointListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n                break;\r\n            }\r\n            case Material.PointFillMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.POINTS;\r\n                break;\r\n            }\r\n            case Material.LineLoopDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_LOOP;\r\n                break;\r\n            }\r\n            case Material.LineListDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINES;\r\n                break;\r\n            }\r\n            case Material.LineStripDrawMode: {\r\n                meshPrimitive.mode = MeshPrimitiveMode.LINE_STRIP;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex attribute accessor based of the glTF mesh primitive\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param attributeKind vertex attribute\r\n     * @returns boolean specifying if uv coordinates are present\r\n     */\r\n    private _setAttributeKind(meshPrimitive: IMeshPrimitive, attributeKind: string): void {\r\n        switch (attributeKind) {\r\n            case VertexBuffer.PositionKind: {\r\n                meshPrimitive.attributes.POSITION = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.NormalKind: {\r\n                meshPrimitive.attributes.NORMAL = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.ColorKind: {\r\n                meshPrimitive.attributes.COLOR_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.TangentKind: {\r\n                meshPrimitive.attributes.TANGENT = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UVKind: {\r\n                meshPrimitive.attributes.TEXCOORD_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.UV2Kind: {\r\n                meshPrimitive.attributes.TEXCOORD_1 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.MatricesIndicesKind: {\r\n                meshPrimitive.attributes.JOINTS_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.MatricesIndicesExtraKind: {\r\n                meshPrimitive.attributes.JOINTS_1 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.MatricesWeightsKind: {\r\n                meshPrimitive.attributes.WEIGHTS_0 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            case VertexBuffer.MatricesWeightsExtraKind: {\r\n                meshPrimitive.attributes.WEIGHTS_1 = this._accessors.length - 1;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Warn(\"Unsupported Vertex Buffer Type: \" + attributeKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets data for the primitive attributes of each submesh\r\n     * @param mesh glTF Mesh object to store the primitive attribute information\r\n     * @param babylonTransformNode Babylon mesh to get the primitive attribute data from\r\n     * @param binaryWriter Buffer to write the attribute data to\r\n     */\r\n    private _setPrimitiveAttributesAsync(mesh: IMesh, babylonTransformNode: TransformNode, binaryWriter: _BinaryWriter): Promise<void> {\r\n        const promises: Promise<IMeshPrimitive>[] = [];\r\n        let bufferMesh: Nullable<Mesh> = null;\r\n        let bufferView: IBufferView;\r\n        let minMax: { min: Nullable<number[]>; max: Nullable<number[]> };\r\n\r\n        if (babylonTransformNode instanceof Mesh) {\r\n            bufferMesh = babylonTransformNode as Mesh;\r\n        } else if (babylonTransformNode instanceof InstancedMesh) {\r\n            bufferMesh = (babylonTransformNode as InstancedMesh).sourceMesh;\r\n        }\r\n        const attributeData: _IVertexAttributeData[] = [\r\n            { kind: VertexBuffer.PositionKind, accessorType: AccessorType.VEC3, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 12 },\r\n            { kind: VertexBuffer.NormalKind, accessorType: AccessorType.VEC3, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 12 },\r\n            { kind: VertexBuffer.ColorKind, accessorType: AccessorType.VEC4, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 16 },\r\n            { kind: VertexBuffer.TangentKind, accessorType: AccessorType.VEC4, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 16 },\r\n            { kind: VertexBuffer.UVKind, accessorType: AccessorType.VEC2, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 8 },\r\n            { kind: VertexBuffer.UV2Kind, accessorType: AccessorType.VEC2, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 8 },\r\n            { kind: VertexBuffer.MatricesIndicesKind, accessorType: AccessorType.VEC4, accessorComponentType: AccessorComponentType.UNSIGNED_SHORT, byteStride: 8 },\r\n            { kind: VertexBuffer.MatricesIndicesExtraKind, accessorType: AccessorType.VEC4, accessorComponentType: AccessorComponentType.UNSIGNED_SHORT, byteStride: 8 },\r\n            { kind: VertexBuffer.MatricesWeightsKind, accessorType: AccessorType.VEC4, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 16 },\r\n            { kind: VertexBuffer.MatricesWeightsExtraKind, accessorType: AccessorType.VEC4, accessorComponentType: AccessorComponentType.FLOAT, byteStride: 16 },\r\n        ];\r\n\r\n        if (bufferMesh) {\r\n            let indexBufferViewIndex: Nullable<number> = null;\r\n            const primitiveMode = this._getMeshPrimitiveMode(bufferMesh);\r\n            const vertexAttributeBufferViews: { [attributeKind: string]: number } = {};\r\n            const morphTargetManager = bufferMesh.morphTargetManager;\r\n\r\n            // For each BabylonMesh, create bufferviews for each 'kind'\r\n            for (const attribute of attributeData) {\r\n                const attributeKind = attribute.kind;\r\n                const attributeComponentKind = attribute.accessorComponentType;\r\n                if (bufferMesh.isVerticesDataPresent(attributeKind, true)) {\r\n                    const vertexBuffer = this._getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                    attribute.byteStride = vertexBuffer\r\n                        ? vertexBuffer.getSize() * VertexBuffer.GetTypeByteLength(attribute.accessorComponentType)\r\n                        : VertexBuffer.DeduceStride(attributeKind) * 4;\r\n                    if (attribute.byteStride === 12) {\r\n                        attribute.accessorType = AccessorType.VEC3;\r\n                    }\r\n\r\n                    this._createBufferViewKind(attributeKind, attributeComponentKind, babylonTransformNode, binaryWriter, attribute.byteStride);\r\n                    attribute.bufferViewIndex = this._bufferViews.length - 1;\r\n                    vertexAttributeBufferViews[attributeKind] = attribute.bufferViewIndex;\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.getTotalIndices()) {\r\n                const indices = bufferMesh.getIndices();\r\n                if (indices) {\r\n                    const byteLength = indices.length * 4;\r\n                    bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, \"Indices - \" + bufferMesh.name);\r\n                    this._bufferViews.push(bufferView);\r\n                    indexBufferViewIndex = this._bufferViews.length - 1;\r\n\r\n                    for (let k = 0, length = indices.length; k < length; ++k) {\r\n                        binaryWriter.setUInt32(indices[k]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (bufferMesh.subMeshes) {\r\n                // go through all mesh primitives (submeshes)\r\n                for (const submesh of bufferMesh.subMeshes) {\r\n                    let babylonMaterial = submesh.getMaterial() || bufferMesh.getScene().defaultMaterial;\r\n\r\n                    let materialIndex: Nullable<number> = null;\r\n                    if (babylonMaterial) {\r\n                        if (bufferMesh instanceof LinesMesh) {\r\n                            // get the color from the lines mesh and set it in the material\r\n                            const material: IMaterial = {\r\n                                name: bufferMesh.name + \" material\",\r\n                            };\r\n                            if (!bufferMesh.color.equals(Color3.White()) || bufferMesh.alpha < 1) {\r\n                                material.pbrMetallicRoughness = {\r\n                                    baseColorFactor: bufferMesh.color.asArray().concat([bufferMesh.alpha]),\r\n                                };\r\n                            }\r\n                            this._materials.push(material);\r\n                            materialIndex = this._materials.length - 1;\r\n                        } else if (babylonMaterial instanceof MultiMaterial) {\r\n                            const subMaterial = babylonMaterial.subMaterials[submesh.materialIndex];\r\n                            if (subMaterial) {\r\n                                babylonMaterial = subMaterial;\r\n                                materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                            }\r\n                        } else {\r\n                            materialIndex = this._materialMap[babylonMaterial.uniqueId];\r\n                        }\r\n                    }\r\n\r\n                    const glTFMaterial: Nullable<IMaterial> = materialIndex != null ? this._materials[materialIndex] : null;\r\n\r\n                    const meshPrimitive: IMeshPrimitive = { attributes: {} };\r\n                    this._setPrimitiveMode(meshPrimitive, primitiveMode);\r\n\r\n                    for (const attribute of attributeData) {\r\n                        const attributeKind = attribute.kind;\r\n                        if ((attributeKind === VertexBuffer.UVKind || attributeKind === VertexBuffer.UV2Kind) && !this._options.exportUnusedUVs) {\r\n                            if (!glTFMaterial || !this._glTFMaterialExporter._hasTexturesPresent(glTFMaterial)) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        const vertexData = bufferMesh.getVerticesData(attributeKind, undefined, undefined, true);\r\n                        if (vertexData) {\r\n                            const vertexBuffer = this._getVertexBufferFromMesh(attributeKind, bufferMesh);\r\n                            if (vertexBuffer) {\r\n                                const stride = vertexBuffer.getSize();\r\n                                const bufferViewIndex = attribute.bufferViewIndex;\r\n                                if (bufferViewIndex != undefined) {\r\n                                    // check to see if bufferviewindex has a numeric value assigned.\r\n                                    minMax = { min: null, max: null };\r\n                                    if (attributeKind == VertexBuffer.PositionKind) {\r\n                                        minMax = _GLTFUtilities._CalculateMinMaxPositions(vertexData, 0, vertexData.length / stride);\r\n                                    }\r\n                                    const accessor = _GLTFUtilities._CreateAccessor(\r\n                                        bufferViewIndex,\r\n                                        attributeKind + \" - \" + babylonTransformNode.name,\r\n                                        attribute.accessorType,\r\n                                        attribute.accessorComponentType,\r\n                                        vertexData.length / stride,\r\n                                        0,\r\n                                        minMax.min,\r\n                                        minMax.max\r\n                                    );\r\n                                    this._accessors.push(accessor);\r\n                                    this._setAttributeKind(meshPrimitive, attributeKind);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (indexBufferViewIndex) {\r\n                        // Create accessor\r\n                        const accessor = _GLTFUtilities._CreateAccessor(\r\n                            indexBufferViewIndex,\r\n                            \"indices - \" + babylonTransformNode.name,\r\n                            AccessorType.SCALAR,\r\n                            AccessorComponentType.UNSIGNED_INT,\r\n                            submesh.indexCount,\r\n                            submesh.indexStart * 4,\r\n                            null,\r\n                            null\r\n                        );\r\n                        this._accessors.push(accessor);\r\n                        meshPrimitive.indices = this._accessors.length - 1;\r\n                    }\r\n\r\n                    if (materialIndex != null && Object.keys(meshPrimitive.attributes).length > 0) {\r\n                        const sideOrientation = bufferMesh.overrideMaterialSideOrientation !== null ? bufferMesh.overrideMaterialSideOrientation : babylonMaterial.sideOrientation;\r\n\r\n                        if (sideOrientation === (this._babylonScene.useRightHandedSystem ? Material.ClockWiseSideOrientation : Material.CounterClockWiseSideOrientation)) {\r\n                            let byteOffset = indexBufferViewIndex != null ? this._bufferViews[indexBufferViewIndex].byteOffset : null;\r\n                            if (byteOffset == null) {\r\n                                byteOffset = 0;\r\n                            }\r\n                            let babylonIndices: Nullable<IndicesArray> = null;\r\n                            if (indexBufferViewIndex != null) {\r\n                                babylonIndices = bufferMesh.getIndices();\r\n                            }\r\n                            if (babylonIndices) {\r\n                                this._reorderIndicesBasedOnPrimitiveMode(submesh, primitiveMode, babylonIndices, byteOffset, binaryWriter);\r\n                            } else {\r\n                                for (const attribute of attributeData) {\r\n                                    const vertexData = bufferMesh.getVerticesData(attribute.kind, undefined, undefined, true);\r\n                                    if (vertexData) {\r\n                                        const byteOffset = this._bufferViews[vertexAttributeBufferViews[attribute.kind]].byteOffset || 0;\r\n                                        this._reorderVertexAttributeDataBasedOnPrimitiveMode(submesh, primitiveMode, attribute.kind, vertexData, byteOffset, binaryWriter);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        meshPrimitive.material = materialIndex;\r\n                    }\r\n                    if (morphTargetManager) {\r\n                        // By convention, morph target names are stored in the mesh extras.\r\n                        if (!mesh.extras) {\r\n                            mesh.extras = {};\r\n                        }\r\n                        mesh.extras.targetNames = [];\r\n\r\n                        for (let i = 0; i < morphTargetManager.numTargets; ++i) {\r\n                            const target = morphTargetManager.getTarget(i);\r\n                            this._setMorphTargetAttributes(submesh, meshPrimitive, target, binaryWriter);\r\n                            mesh.extras.targetNames.push(target.name);\r\n                        }\r\n                    }\r\n\r\n                    mesh.primitives.push(meshPrimitive);\r\n\r\n                    this._extensionsPostExportMeshPrimitiveAsync(\"postExport\", meshPrimitive, submesh, binaryWriter);\r\n                    promises.push();\r\n                }\r\n            }\r\n        }\r\n        return Promise.all(promises).then(() => {\r\n            /* do nothing */\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF scene based on the array of meshes\r\n     * Returns the total byte offset\r\n     * @param babylonScene Babylon scene to get the mesh data from\r\n     * @param binaryWriter Buffer to write binary data to\r\n     */\r\n    private _createSceneAsync(binaryWriter: _BinaryWriter): Promise<void> {\r\n        const scene: IScene = { nodes: [] };\r\n        let glTFNodeIndex: number;\r\n        let glTFNode: INode;\r\n        let directDescendents: Node[];\r\n        const nodes: Node[] = [...this._babylonScene.transformNodes, ...this._babylonScene.meshes, ...this._babylonScene.lights, ...this._babylonScene.cameras];\r\n        const removedRootNodes = new Set<Node>();\r\n\r\n        // Scene metadata\r\n        if (this._babylonScene.metadata) {\r\n            if (this._options.metadataSelector) {\r\n                scene.extras = this._options.metadataSelector(this._babylonScene.metadata);\r\n            } else if (this._babylonScene.metadata.gltf) {\r\n                scene.extras = this._babylonScene.metadata.gltf.extras;\r\n            }\r\n        }\r\n\r\n        // Remove no-op root nodes\r\n        if ((this._options.removeNoopRootNodes ?? true) && !this._options.includeCoordinateSystemConversionNodes) {\r\n            for (const rootNode of this._babylonScene.rootNodes) {\r\n                if (isNoopNode(rootNode, this._babylonScene.useRightHandedSystem)) {\r\n                    removedRootNodes.add(rootNode);\r\n\r\n                    // Exclude the node from list of nodes to export\r\n                    nodes.splice(nodes.indexOf(rootNode), 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Export babylon cameras to glTFCamera\r\n        const cameraMap = new Map<Camera, number>();\r\n        this._babylonScene.cameras.forEach((camera) => {\r\n            if (!this._options.shouldExportNode || this._options.shouldExportNode(camera)) {\r\n                const glTFCamera: ICamera = {\r\n                    type: camera.mode === Camera.PERSPECTIVE_CAMERA ? CameraType.PERSPECTIVE : CameraType.ORTHOGRAPHIC,\r\n                };\r\n\r\n                if (camera.name) {\r\n                    glTFCamera.name = camera.name;\r\n                }\r\n\r\n                if (glTFCamera.type === CameraType.PERSPECTIVE) {\r\n                    glTFCamera.perspective = {\r\n                        aspectRatio: camera.getEngine().getAspectRatio(camera),\r\n                        yfov: camera.fovMode === Camera.FOVMODE_VERTICAL_FIXED ? camera.fov : camera.fov * camera.getEngine().getAspectRatio(camera),\r\n                        znear: camera.minZ,\r\n                        zfar: camera.maxZ,\r\n                    };\r\n                } else if (glTFCamera.type === CameraType.ORTHOGRAPHIC) {\r\n                    const halfWidth = camera.orthoLeft && camera.orthoRight ? 0.5 * (camera.orthoRight - camera.orthoLeft) : camera.getEngine().getRenderWidth() * 0.5;\r\n                    const halfHeight = camera.orthoBottom && camera.orthoTop ? 0.5 * (camera.orthoTop - camera.orthoBottom) : camera.getEngine().getRenderHeight() * 0.5;\r\n                    glTFCamera.orthographic = {\r\n                        xmag: halfWidth,\r\n                        ymag: halfHeight,\r\n                        znear: camera.minZ,\r\n                        zfar: camera.maxZ,\r\n                    };\r\n                }\r\n\r\n                cameraMap.set(camera, this._cameras.length);\r\n                this._cameras.push(glTFCamera);\r\n            }\r\n        });\r\n\r\n        const [exportNodes, exportMaterials] = this._getExportNodes(nodes);\r\n        return this._glTFMaterialExporter._convertMaterialsToGLTFAsync(exportMaterials, ImageMimeType.PNG, true).then(() => {\r\n            return this._createNodeMapAndAnimationsAsync(exportNodes, binaryWriter).then((nodeMap) => {\r\n                return this._createSkinsAsync(nodeMap, binaryWriter).then((skinMap) => {\r\n                    this._nodeMap = nodeMap;\r\n\r\n                    this._totalByteLength = binaryWriter.getByteOffset();\r\n                    if (this._totalByteLength == undefined) {\r\n                        throw new Error(\"undefined byte length!\");\r\n                    }\r\n\r\n                    // Build Hierarchy with the node map.\r\n                    for (const babylonNode of nodes) {\r\n                        glTFNodeIndex = this._nodeMap[babylonNode.uniqueId];\r\n                        if (glTFNodeIndex !== undefined) {\r\n                            glTFNode = this._nodes[glTFNodeIndex];\r\n\r\n                            if (babylonNode.metadata) {\r\n                                if (this._options.metadataSelector) {\r\n                                    glTFNode.extras = this._options.metadataSelector(babylonNode.metadata);\r\n                                } else if (babylonNode.metadata.gltf) {\r\n                                    glTFNode.extras = babylonNode.metadata.gltf.extras;\r\n                                }\r\n                            }\r\n\r\n                            if (babylonNode instanceof Camera) {\r\n                                glTFNode.camera = cameraMap.get(babylonNode);\r\n                            }\r\n\r\n                            if (this._options.shouldExportNode && !this._options.shouldExportNode(babylonNode)) {\r\n                                Tools.Log(\"Omitting \" + babylonNode.name + \" from scene.\");\r\n                            } else {\r\n                                if (!babylonNode.parent && !this._babylonScene.useRightHandedSystem) {\r\n                                    convertNodeHandedness(glTFNode);\r\n                                }\r\n\r\n                                if (!babylonNode.parent || removedRootNodes.has(babylonNode.parent)) {\r\n                                    scene.nodes.push(glTFNodeIndex);\r\n                                }\r\n                            }\r\n\r\n                            if (babylonNode instanceof Mesh) {\r\n                                if (babylonNode.skeleton) {\r\n                                    glTFNode.skin = skinMap[babylonNode.skeleton.uniqueId];\r\n                                }\r\n                            }\r\n\r\n                            directDescendents = babylonNode.getDescendants(true);\r\n                            if (!glTFNode.children && directDescendents && directDescendents.length) {\r\n                                const children: number[] = [];\r\n                                for (const descendent of directDescendents) {\r\n                                    if (this._nodeMap[descendent.uniqueId] != null) {\r\n                                        children.push(this._nodeMap[descendent.uniqueId]);\r\n                                    }\r\n                                }\r\n                                if (children.length) {\r\n                                    glTFNode.children = children;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (scene.nodes.length) {\r\n                        this._scenes.push(scene);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Getting the nodes and materials that would be exported.\r\n     * @param nodes Babylon transform nodes\r\n     * @returns Array of nodes which would be exported.\r\n     * @returns Set of materials which would be exported.\r\n     */\r\n    private _getExportNodes(nodes: Node[]): [Node[], Set<Material>] {\r\n        const exportNodes: Node[] = [];\r\n        const exportMaterials: Set<Material> = new Set<Material>();\r\n\r\n        for (const babylonNode of nodes) {\r\n            if (!this._options.shouldExportNode || this._options.shouldExportNode(babylonNode)) {\r\n                exportNodes.push(babylonNode);\r\n\r\n                const babylonMesh = babylonNode as AbstractMesh;\r\n                if (babylonMesh.subMeshes && babylonMesh.subMeshes.length > 0) {\r\n                    const material = babylonMesh.material || babylonMesh.getScene().defaultMaterial;\r\n                    if (material instanceof MultiMaterial) {\r\n                        for (const subMaterial of material.subMaterials) {\r\n                            if (subMaterial) {\r\n                                exportMaterials.add(subMaterial);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        exportMaterials.add(material);\r\n                    }\r\n                }\r\n            } else {\r\n                `Excluding node ${babylonNode.name}`;\r\n            }\r\n        }\r\n\r\n        return [exportNodes, exportMaterials];\r\n    }\r\n\r\n    /**\r\n     * Creates a mapping of Node unique id to node index and handles animations\r\n     * @param nodes Babylon transform nodes\r\n     * @param binaryWriter Buffer to write binary data to\r\n     * @returns Node mapping of unique id to index\r\n     */\r\n    private _createNodeMapAndAnimationsAsync(nodes: Node[], binaryWriter: _BinaryWriter): Promise<{ [key: number]: number }> {\r\n        let promiseChain = Promise.resolve();\r\n        const nodeMap: { [key: number]: number } = {};\r\n        let nodeIndex: number;\r\n        const runtimeGLTFAnimation: IAnimation = {\r\n            name: \"runtime animations\",\r\n            channels: [],\r\n            samplers: [],\r\n        };\r\n        const idleGLTFAnimations: IAnimation[] = [];\r\n\r\n        for (const babylonNode of nodes) {\r\n            promiseChain = promiseChain.then(() => {\r\n                return this._createNodeAsync(babylonNode, binaryWriter).then((node) => {\r\n                    const promise = this._extensionsPostExportNodeAsync(\"createNodeAsync\", node, babylonNode, nodeMap, binaryWriter);\r\n                    if (promise == null) {\r\n                        Tools.Warn(`Not exporting node ${babylonNode.name}`);\r\n                        return Promise.resolve();\r\n                    } else {\r\n                        return promise.then((node) => {\r\n                            if (!node) {\r\n                                return;\r\n                            }\r\n                            this._nodes.push(node);\r\n                            nodeIndex = this._nodes.length - 1;\r\n                            nodeMap[babylonNode.uniqueId] = nodeIndex;\r\n\r\n                            if (!this._babylonScene.animationGroups.length) {\r\n                                _GLTFAnimation._CreateMorphTargetAnimationFromMorphTargetAnimations(\r\n                                    babylonNode,\r\n                                    runtimeGLTFAnimation,\r\n                                    idleGLTFAnimations,\r\n                                    nodeMap,\r\n                                    this._nodes,\r\n                                    binaryWriter,\r\n                                    this._bufferViews,\r\n                                    this._accessors,\r\n                                    this._animationSampleRate,\r\n                                    this._options.shouldExportAnimation\r\n                                );\r\n                                if (babylonNode.animations.length) {\r\n                                    _GLTFAnimation._CreateNodeAnimationFromNodeAnimations(\r\n                                        babylonNode,\r\n                                        runtimeGLTFAnimation,\r\n                                        idleGLTFAnimations,\r\n                                        nodeMap,\r\n                                        this._nodes,\r\n                                        binaryWriter,\r\n                                        this._bufferViews,\r\n                                        this._accessors,\r\n                                        this._animationSampleRate,\r\n                                        this._options.shouldExportAnimation\r\n                                    );\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        return promiseChain.then(() => {\r\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\r\n                this._animations.push(runtimeGLTFAnimation);\r\n            }\r\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\r\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\r\n                    this._animations.push(idleGLTFAnimation);\r\n                }\r\n            });\r\n\r\n            if (this._babylonScene.animationGroups.length) {\r\n                _GLTFAnimation._CreateNodeAndMorphAnimationFromAnimationGroups(\r\n                    this._babylonScene,\r\n                    this._animations,\r\n                    nodeMap,\r\n                    binaryWriter,\r\n                    this._bufferViews,\r\n                    this._accessors,\r\n                    this._animationSampleRate,\r\n                    this._options.shouldExportAnimation\r\n                );\r\n            }\r\n\r\n            return nodeMap;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF node from a Babylon mesh\r\n     * @param babylonNode Source Babylon mesh\r\n     * @param binaryWriter Buffer for storing geometry data\r\n     * @returns glTF node\r\n     */\r\n    private _createNodeAsync(babylonNode: Node, binaryWriter: _BinaryWriter): Promise<INode> {\r\n        return Promise.resolve().then(() => {\r\n            // create node to hold translation/rotation/scale and the mesh\r\n            const node: INode = {};\r\n            // create mesh\r\n            const mesh: IMesh = { primitives: [] };\r\n\r\n            if (babylonNode.name) {\r\n                node.name = babylonNode.name;\r\n            }\r\n\r\n            if (babylonNode instanceof TransformNode) {\r\n                // Set transformation\r\n                this._setNodeTransformation(node, babylonNode);\r\n                if (babylonNode instanceof Mesh) {\r\n                    const morphTargetManager = babylonNode.morphTargetManager;\r\n                    if (morphTargetManager && morphTargetManager.numTargets > 0) {\r\n                        mesh.weights = [];\r\n                        for (let i = 0; i < morphTargetManager.numTargets; ++i) {\r\n                            mesh.weights.push(morphTargetManager.getTarget(i).influence);\r\n                        }\r\n                    }\r\n                }\r\n                return this._setPrimitiveAttributesAsync(mesh, babylonNode, binaryWriter).then(() => {\r\n                    if (mesh.primitives.length) {\r\n                        this._meshes.push(mesh);\r\n                        node.mesh = this._meshes.length - 1;\r\n                    }\r\n                    return node;\r\n                });\r\n            } else if (babylonNode instanceof Camera) {\r\n                this._setCameraTransformation(node, babylonNode);\r\n                return node;\r\n            } else {\r\n                return node;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF skin from a Babylon skeleton\r\n     * @param babylonScene Babylon Scene\r\n     * @param nodeMap Babylon transform nodes\r\n     * @param binaryWriter Buffer to write binary data to\r\n     * @returns Node mapping of unique id to index\r\n     */\r\n    private _createSkinsAsync(nodeMap: { [key: number]: number }, binaryWriter: _BinaryWriter): Promise<{ [key: number]: number }> {\r\n        const promiseChain = Promise.resolve();\r\n        const skinMap: { [key: number]: number } = {};\r\n        for (const skeleton of this._babylonScene.skeletons) {\r\n            if (skeleton.bones.length <= 0) {\r\n                continue;\r\n            }\r\n            // create skin\r\n            const skin: ISkin = { joints: [] };\r\n            const inverseBindMatrices: Matrix[] = [];\r\n\r\n            const boneIndexMap: { [index: number]: Bone } = {};\r\n            let maxBoneIndex = -1;\r\n            for (let i = 0; i < skeleton.bones.length; ++i) {\r\n                const bone = skeleton.bones[i];\r\n                const boneIndex = bone.getIndex() ?? i;\r\n                if (boneIndex !== -1) {\r\n                    boneIndexMap[boneIndex] = bone;\r\n                    if (boneIndex > maxBoneIndex) {\r\n                        maxBoneIndex = boneIndex;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (let boneIndex = 0; boneIndex <= maxBoneIndex; ++boneIndex) {\r\n                const bone = boneIndexMap[boneIndex];\r\n                inverseBindMatrices.push(bone.getInvertedAbsoluteTransform());\r\n\r\n                const transformNode = bone.getTransformNode();\r\n                if (transformNode && nodeMap[transformNode.uniqueId] !== null && nodeMap[transformNode.uniqueId] !== undefined) {\r\n                    skin.joints.push(nodeMap[transformNode.uniqueId]);\r\n                } else {\r\n                    Tools.Warn(\"Exporting a bone without a linked transform node is currently unsupported\");\r\n                }\r\n            }\r\n\r\n            if (skin.joints.length > 0) {\r\n                // create buffer view for inverse bind matrices\r\n                const byteStride = 64; // 4 x 4 matrix of 32 bit float\r\n                const byteLength = inverseBindMatrices.length * byteStride;\r\n                const bufferViewOffset = binaryWriter.getByteOffset();\r\n                const bufferView = _GLTFUtilities._CreateBufferView(0, bufferViewOffset, byteLength, undefined, \"InverseBindMatrices\" + \" - \" + skeleton.name);\r\n                this._bufferViews.push(bufferView);\r\n                const bufferViewIndex = this._bufferViews.length - 1;\r\n                const bindMatrixAccessor = _GLTFUtilities._CreateAccessor(\r\n                    bufferViewIndex,\r\n                    \"InverseBindMatrices\" + \" - \" + skeleton.name,\r\n                    AccessorType.MAT4,\r\n                    AccessorComponentType.FLOAT,\r\n                    inverseBindMatrices.length,\r\n                    null,\r\n                    null,\r\n                    null\r\n                );\r\n                const inverseBindAccessorIndex = this._accessors.push(bindMatrixAccessor) - 1;\r\n                skin.inverseBindMatrices = inverseBindAccessorIndex;\r\n                this._skins.push(skin);\r\n                skinMap[skeleton.uniqueId] = this._skins.length - 1;\r\n\r\n                inverseBindMatrices.forEach((mat) => {\r\n                    mat.m.forEach((cell: number) => {\r\n                        binaryWriter.setFloat32(cell);\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        return promiseChain.then(() => {\r\n            return skinMap;\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * Stores glTF binary data.  If the array buffer byte length is exceeded, it doubles in size dynamically\r\n */\r\nexport class _BinaryWriter {\r\n    /**\r\n     * Array buffer which stores all binary data\r\n     */\r\n    private _arrayBuffer: ArrayBuffer;\r\n    /**\r\n     * View of the array buffer\r\n     */\r\n    private _dataView: DataView;\r\n    /**\r\n     * byte offset of data in array buffer\r\n     */\r\n    private _byteOffset: number;\r\n    /**\r\n     * Initialize binary writer with an initial byte length\r\n     * @param byteLength Initial byte length of the array buffer\r\n     */\r\n    constructor(byteLength: number) {\r\n        this._arrayBuffer = new ArrayBuffer(byteLength);\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n        this._byteOffset = 0;\r\n    }\r\n    /**\r\n     * Resize the array buffer to the specified byte length\r\n     * @param byteLength\r\n     */\r\n    private _resizeBuffer(byteLength: number): ArrayBuffer {\r\n        const newBuffer = new ArrayBuffer(byteLength);\r\n        const copyOldBufferSize = Math.min(this._arrayBuffer.byteLength, byteLength);\r\n        const oldUint8Array = new Uint8Array(this._arrayBuffer, 0, copyOldBufferSize);\r\n        const newUint8Array = new Uint8Array(newBuffer);\r\n        newUint8Array.set(oldUint8Array, 0);\r\n        this._arrayBuffer = newBuffer;\r\n        this._dataView = new DataView(this._arrayBuffer);\r\n\r\n        return newBuffer;\r\n    }\r\n    /**\r\n     * Get an array buffer with the length of the byte offset\r\n     * @returns ArrayBuffer resized to the byte offset\r\n     */\r\n    public getArrayBuffer(): ArrayBuffer {\r\n        return this._resizeBuffer(this.getByteOffset());\r\n    }\r\n    /**\r\n     * Get the byte offset of the array buffer\r\n     * @returns byte offset\r\n     */\r\n    public getByteOffset(): number {\r\n        if (this._byteOffset == undefined) {\r\n            throw new Error(\"Byte offset is undefined!\");\r\n        }\r\n        return this._byteOffset;\r\n    }\r\n    /**\r\n     * Stores an UInt8 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt8(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint8(byteOffset, entry);\r\n            } else {\r\n                Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n            }\r\n        } else {\r\n            if (this._byteOffset + 1 > this._arrayBuffer.byteLength) {\r\n                this._resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint8(this._byteOffset, entry);\r\n            this._byteOffset += 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores an UInt16 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt16(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint16(byteOffset, entry, true);\r\n            } else {\r\n                Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n            }\r\n        } else {\r\n            if (this._byteOffset + 2 > this._arrayBuffer.byteLength) {\r\n                this._resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint16(this._byteOffset, entry, true);\r\n            this._byteOffset += 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets an UInt32 in the array buffer\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public getUInt32(byteOffset: number): number {\r\n        if (byteOffset < this._byteOffset) {\r\n            return this._dataView.getUint32(byteOffset, true);\r\n        } else {\r\n            Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n            throw new Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n        }\r\n    }\r\n\r\n    public getVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        } else {\r\n            vector3.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector3.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector3.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n        }\r\n    }\r\n\r\n    public setVector3Float32FromRef(vector3: Vector3, byteOffset: number): void {\r\n        if (byteOffset + 8 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        } else {\r\n            this._dataView.setFloat32(byteOffset, vector3.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector3.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector3.z, true);\r\n        }\r\n    }\r\n\r\n    public getVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        } else {\r\n            vector4.x = this._dataView.getFloat32(byteOffset, true);\r\n            vector4.y = this._dataView.getFloat32(byteOffset + 4, true);\r\n            vector4.z = this._dataView.getFloat32(byteOffset + 8, true);\r\n            vector4.w = this._dataView.getFloat32(byteOffset + 12, true);\r\n        }\r\n    }\r\n\r\n    public setVector4Float32FromRef(vector4: Vector4, byteOffset: number): void {\r\n        if (byteOffset + 12 > this._byteOffset) {\r\n            Tools.Error(`BinaryWriter: byteoffset is greater than the current binary buffer length!`);\r\n        } else {\r\n            this._dataView.setFloat32(byteOffset, vector4.x, true);\r\n            this._dataView.setFloat32(byteOffset + 4, vector4.y, true);\r\n            this._dataView.setFloat32(byteOffset + 8, vector4.z, true);\r\n            this._dataView.setFloat32(byteOffset + 12, vector4.w, true);\r\n        }\r\n    }\r\n    /**\r\n     * Stores a Float32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset\r\n     */\r\n    public setFloat32(entry: number, byteOffset?: number) {\r\n        if (isNaN(entry)) {\r\n            Tools.Error(\"Invalid data being written!\");\r\n        }\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setFloat32(byteOffset, entry, true);\r\n            } else {\r\n                Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary length!\");\r\n            }\r\n        }\r\n        if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n            this._resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n        }\r\n        this._dataView.setFloat32(this._byteOffset, entry, true);\r\n        this._byteOffset += 4;\r\n    }\r\n    /**\r\n     * Stores an UInt32 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setUInt32(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setUint32(byteOffset, entry, true);\r\n            } else {\r\n                Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n            }\r\n        } else {\r\n            if (this._byteOffset + 4 > this._arrayBuffer.byteLength) {\r\n                this._resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setUint32(this._byteOffset, entry, true);\r\n            this._byteOffset += 4;\r\n        }\r\n    }\r\n    /**\r\n     * Stores an Int16 in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setInt16(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setInt16(byteOffset, entry, true);\r\n            } else {\r\n                Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n            }\r\n        } else {\r\n            if (this._byteOffset + 2 > this._arrayBuffer.byteLength) {\r\n                this._resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setInt16(this._byteOffset, entry, true);\r\n            this._byteOffset += 2;\r\n        }\r\n    }\r\n    /**\r\n     * Stores a byte in the array buffer\r\n     * @param entry\r\n     * @param byteOffset If defined, specifies where to set the value as an offset.\r\n     */\r\n    public setByte(entry: number, byteOffset?: number) {\r\n        if (byteOffset != null) {\r\n            if (byteOffset < this._byteOffset) {\r\n                this._dataView.setInt8(byteOffset, entry);\r\n            } else {\r\n                Tools.Error(\"BinaryWriter: byteoffset is greater than the current binary buffer length!\");\r\n            }\r\n        } else {\r\n            if (this._byteOffset + 1 > this._arrayBuffer.byteLength) {\r\n                this._resizeBuffer(this._arrayBuffer.byteLength * 2);\r\n            }\r\n            this._dataView.setInt8(this._byteOffset, entry);\r\n            this._byteOffset++;\r\n        }\r\n    }\r\n}\r\n","import type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { GLTFData } from \"./glTFData\";\r\nimport { _Exporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Holds a collection of exporter options and parameters\r\n */\r\nexport interface IExportOptions {\r\n    /**\r\n     * Function which indicates whether a babylon node should be exported or not\r\n     * @param node source Babylon node. It is used to check whether it should be exported to glTF or not\r\n     * @returns boolean, which indicates whether the node should be exported (true) or not (false)\r\n     */\r\n    shouldExportNode?(node: Node): boolean;\r\n\r\n    /**\r\n     * Function which indicates whether an animation on the scene should be exported or not\r\n     * @param animation source animation\r\n     * @returns boolean, which indicates whether the animation should be exported (true) or not (false)\r\n     */\r\n    shouldExportAnimation?(animation: Animation): boolean;\r\n\r\n    /**\r\n     * Function used to extract the part of node's metadata that will be exported into glTF node extras\r\n     * @param metadata source metadata to read from\r\n     * @returns the data to store to glTF node extras\r\n     */\r\n    metadataSelector?(metadata: any): any;\r\n\r\n    /**\r\n     * The sample rate to bake animation curves. Defaults to 1 / 60.\r\n     */\r\n    animationSampleRate?: number;\r\n\r\n    /**\r\n     * Begin serialization without waiting for the scene to be ready. Defaults to false.\r\n     */\r\n    exportWithoutWaitingForScene?: boolean;\r\n\r\n    /**\r\n     * Indicates if unused vertex uv attributes should be included in export. Defaults to false.\r\n     */\r\n    exportUnusedUVs?: boolean;\r\n\r\n    /**\r\n     * Remove no-op root nodes when possible. Defaults to true.\r\n     */\r\n    removeNoopRootNodes?: boolean;\r\n\r\n    /**\r\n     * Indicates if coordinate system swapping root nodes should be included in export. Defaults to false.\r\n     * @deprecated Please use removeNoopRootNodes instead\r\n     */\r\n    includeCoordinateSystemConversionNodes?: boolean;\r\n}\r\n\r\n/**\r\n * Class for generating glTF data from a Babylon scene.\r\n */\r\nexport class GLTF2Export {\r\n    /**\r\n     * Exports the geometry of the scene to .gltf file format asynchronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating the glTF file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .gltf file and associates texture names\r\n     * as keys and their data and paths as values\r\n     */\r\n    public static GLTFAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return scene.whenReadyAsync().then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLTFAsync(glTFPrefix);\r\n        });\r\n    }\r\n\r\n    private static _PreExportAsync(scene: Scene, options?: IExportOptions): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return Promise.resolve();\r\n            } else {\r\n                return scene.whenReadyAsync();\r\n            }\r\n        });\r\n    }\r\n\r\n    private static _PostExportAsync(scene: Scene, glTFData: GLTFData, options?: IExportOptions): Promise<GLTFData> {\r\n        return Promise.resolve().then(() => {\r\n            if (options && options.exportWithoutWaitingForScene) {\r\n                return glTFData;\r\n            } else {\r\n                return glTFData;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Exports the geometry of the scene to .glb file format asychronously\r\n     * @param scene Babylon scene with scene hierarchy information\r\n     * @param filePrefix File prefix to use when generating glb file\r\n     * @param options Exporter options\r\n     * @returns Returns an object with a .glb filename as key and data as value\r\n     */\r\n    public static GLBAsync(scene: Scene, filePrefix: string, options?: IExportOptions): Promise<GLTFData> {\r\n        return this._PreExportAsync(scene, options).then(() => {\r\n            const glTFPrefix = filePrefix.replace(/\\.[^/.]+$/, \"\");\r\n            const gltfGenerator = new _Exporter(scene, options);\r\n            return gltfGenerator._generateGLBAsync(glTFPrefix).then((glTFData) => {\r\n                return this._PostExportAsync(scene, glTFData, options);\r\n            });\r\n        });\r\n    }\r\n}\r\n","import type { ITextureInfo, IKHRTextureTransform } from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_texture_transform implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: Texture): void {\r\n        const canUseExtension =\r\n            babylonTexture &&\r\n            ((babylonTexture.uAng === 0 && babylonTexture.wAng === 0 && babylonTexture.vAng === 0) ||\r\n                (babylonTexture.uRotationCenter === 0 && babylonTexture.vRotationCenter === 0));\r\n\r\n        if (canUseExtension) {\r\n            const textureTransform: IKHRTextureTransform = {};\r\n            let transformIsRequired = false;\r\n\r\n            if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {\r\n                textureTransform.offset = [babylonTexture.uOffset, babylonTexture.vOffset];\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {\r\n                textureTransform.scale = [babylonTexture.uScale, babylonTexture.vScale];\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.wAng !== 0) {\r\n                textureTransform.rotation = -babylonTexture.wAng;\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (babylonTexture.coordinatesIndex !== 0) {\r\n                textureTransform.texCoord = babylonTexture.coordinatesIndex;\r\n                transformIsRequired = true;\r\n            }\r\n\r\n            if (!transformIsRequired) {\r\n                return;\r\n            }\r\n\r\n            this._wasUsed = true;\r\n            if (!textureInfo.extensions) {\r\n                textureInfo.extensions = {};\r\n            }\r\n            textureInfo.extensions[NAME] = textureTransform;\r\n        }\r\n    }\r\n\r\n    public preExportTextureAsync(context: string, babylonTexture: Texture): Promise<Nullable<Texture>> {\r\n        return new Promise((resolve, reject) => {\r\n            const scene = babylonTexture.getScene();\r\n            if (!scene) {\r\n                reject(`${context}: \"scene\" is not defined for Babylon texture ${babylonTexture.name}!`);\r\n                return;\r\n            }\r\n\r\n            /*\r\n             * The KHR_texture_transform schema only supports w rotation around the origin.\r\n             * See https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates.\r\n             */\r\n            if (babylonTexture.uAng !== 0 || babylonTexture.vAng !== 0) {\r\n                Tools.Warn(`${context}: Texture ${babylonTexture.name} with rotation in the u or v axis is not supported in glTF.`);\r\n                resolve(null);\r\n            } else if (babylonTexture.wAng !== 0 && (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0)) {\r\n                Tools.Warn(`${context}: Texture ${babylonTexture.name} with rotation not centered at the origin cannot be exported with ${NAME}`);\r\n                resolve(null);\r\n            } else {\r\n                resolve(babylonTexture);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, () => new KHR_texture_transform());\r\n","import type { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3, Quaternion, TmpVectors, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { Node } from \"core/node\";\r\nimport { ShadowLight } from \"core/Lights/shadowLight\";\r\nimport type { INode, IKHRLightsPunctual_LightReference, IKHRLightsPunctual_Light, IKHRLightsPunctual } from \"babylonjs-gltf2interface\";\r\nimport { KHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { _GLTFUtilities } from \"../glTFUtilities\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_lights_punctual implements IGLTFExporterExtensionV2 {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _exporter: _Exporter;\r\n\r\n    private _lights: IKHRLightsPunctual;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._lights as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return !!this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onExporting(): void {\r\n        this._exporter!._glTF.extensions![NAME] = this._lights;\r\n    }\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a node\r\n     * @param context The context when exporting the node\r\n     * @param node glTF node\r\n     * @param babylonNode BabylonJS node\r\n     * @param nodeMap Node mapping of unique id to glTF node index\r\n     * @returns nullable INode promise\r\n     */\r\n    public postExportNodeAsync(context: string, node: Nullable<INode>, babylonNode: Node, nodeMap: { [key: number]: number }): Promise<Nullable<INode>> {\r\n        return new Promise((resolve) => {\r\n            if (node && babylonNode instanceof ShadowLight) {\r\n                let light: IKHRLightsPunctual_Light;\r\n\r\n                const lightType =\r\n                    babylonNode.getTypeID() == Light.LIGHTTYPEID_POINTLIGHT\r\n                        ? KHRLightsPunctual_LightType.POINT\r\n                        : babylonNode.getTypeID() == Light.LIGHTTYPEID_DIRECTIONALLIGHT\r\n                          ? KHRLightsPunctual_LightType.DIRECTIONAL\r\n                          : babylonNode.getTypeID() == Light.LIGHTTYPEID_SPOTLIGHT\r\n                            ? KHRLightsPunctual_LightType.SPOT\r\n                            : null;\r\n                if (lightType == null) {\r\n                    Logger.Warn(`${context}: Light ${babylonNode.name} is not supported in ${NAME}`);\r\n                } else {\r\n                    if (!babylonNode.position.equalsToFloats(0, 0, 0)) {\r\n                        node.translation = babylonNode.position.asArray();\r\n                    }\r\n                    if (lightType !== KHRLightsPunctual_LightType.POINT) {\r\n                        const localAxis = babylonNode.direction;\r\n                        const yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;\r\n                        const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);\r\n                        const pitch = -Math.atan2(localAxis.y, len);\r\n                        const lightRotationQuaternion = Quaternion.RotationYawPitchRoll(yaw + Math.PI, pitch, 0);\r\n                        if (!Quaternion.IsIdentity(lightRotationQuaternion)) {\r\n                            node.rotation = lightRotationQuaternion.asArray();\r\n                        }\r\n                    }\r\n\r\n                    if (babylonNode.falloffType !== Light.FALLOFF_GLTF) {\r\n                        Logger.Warn(`${context}: Light falloff for ${babylonNode.name} does not match the ${NAME} specification!`);\r\n                    }\r\n                    light = {\r\n                        type: lightType,\r\n                    };\r\n                    if (!babylonNode.diffuse.equals(Color3.White())) {\r\n                        light.color = babylonNode.diffuse.asArray();\r\n                    }\r\n                    if (babylonNode.intensity !== 1.0) {\r\n                        light.intensity = babylonNode.intensity;\r\n                    }\r\n                    if (babylonNode.range !== Number.MAX_VALUE) {\r\n                        light.range = babylonNode.range;\r\n                    }\r\n\r\n                    if (lightType === KHRLightsPunctual_LightType.SPOT) {\r\n                        const babylonSpotLight = babylonNode as SpotLight;\r\n                        if (babylonSpotLight.angle !== Math.PI / 2.0) {\r\n                            if (light.spot == null) {\r\n                                light.spot = {};\r\n                            }\r\n                            light.spot.outerConeAngle = babylonSpotLight.angle / 2.0;\r\n                        }\r\n                        if (babylonSpotLight.innerAngle !== 0) {\r\n                            if (light.spot == null) {\r\n                                light.spot = {};\r\n                            }\r\n                            light.spot.innerConeAngle = babylonSpotLight.innerAngle / 2.0;\r\n                        }\r\n                    }\r\n\r\n                    this._lights ||= {\r\n                        lights: [],\r\n                    };\r\n\r\n                    this._lights.lights.push(light);\r\n\r\n                    const lightReference: IKHRLightsPunctual_LightReference = {\r\n                        light: this._lights.lights.length - 1,\r\n                    };\r\n\r\n                    // Avoid duplicating the Light's parent node if possible.\r\n                    const parentBabylonNode = babylonNode.parent;\r\n                    if (parentBabylonNode && parentBabylonNode.getChildren().length == 1) {\r\n                        const parentNode = this._exporter._nodes[nodeMap[parentBabylonNode.uniqueId]];\r\n                        if (parentNode) {\r\n                            const parentTranslation = Vector3.FromArrayToRef(parentNode.translation || [0, 0, 0], 0, TmpVectors.Vector3[0]);\r\n                            const parentRotation = Quaternion.FromArrayToRef(parentNode.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[0]);\r\n                            const parentScale = Vector3.FromArrayToRef(parentNode.scale || [1, 1, 1], 0, TmpVectors.Vector3[1]);\r\n                            const parentMatrix = Matrix.ComposeToRef(parentScale, parentRotation, parentTranslation, TmpVectors.Matrix[0]);\r\n\r\n                            const translation = Vector3.FromArrayToRef(node.translation || [0, 0, 0], 0, TmpVectors.Vector3[2]);\r\n                            const rotation = Quaternion.FromArrayToRef(node.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[1]);\r\n                            const matrix = Matrix.ComposeToRef(Vector3.OneReadOnly, rotation, translation, TmpVectors.Matrix[1]);\r\n\r\n                            parentMatrix.multiplyToRef(matrix, matrix);\r\n                            matrix.decompose(parentScale, parentRotation, parentTranslation);\r\n\r\n                            if (parentTranslation.equalsToFloats(0, 0, 0)) {\r\n                                delete parentNode.translation;\r\n                            } else {\r\n                                parentNode.translation = parentTranslation.asArray();\r\n                            }\r\n\r\n                            if (Quaternion.IsIdentity(parentRotation)) {\r\n                                delete parentNode.rotation;\r\n                            } else {\r\n                                parentNode.rotation = parentRotation.asArray();\r\n                            }\r\n\r\n                            if (parentScale.equalsToFloats(1, 1, 1)) {\r\n                                delete parentNode.scale;\r\n                            } else {\r\n                                parentNode.scale = parentScale.asArray();\r\n                            }\r\n\r\n                            parentNode.extensions ||= {};\r\n                            parentNode.extensions[NAME] = lightReference;\r\n\r\n                            // Do not export the original node\r\n                            resolve(null);\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    node.extensions ||= {};\r\n                    node.extensions[NAME] = lightReference;\r\n                }\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_lights_punctual(exporter));\r\n","import type { IMaterial, IKHRMaterialsClearcoat } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: _Exporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.clearCoat.isEnabled) {\r\n                if (babylonMaterial.clearCoat.texture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.texture);\r\n                }\r\n                if (!babylonMaterial.clearCoat.useRoughnessFromMainTexture && babylonMaterial.clearCoat.textureRoughness) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.textureRoughness);\r\n                }\r\n                if (babylonMaterial.clearCoat.bumpTexture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.bumpTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.clearCoat.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const clearCoatTextureInfo = this._exporter._glTFMaterialExporter._getTextureInfo(babylonMaterial.clearCoat.texture);\r\n                let clearCoatTextureRoughnessInfo;\r\n                if (babylonMaterial.clearCoat.useRoughnessFromMainTexture) {\r\n                    clearCoatTextureRoughnessInfo = this._exporter._glTFMaterialExporter._getTextureInfo(babylonMaterial.clearCoat.texture);\r\n                } else {\r\n                    clearCoatTextureRoughnessInfo = this._exporter._glTFMaterialExporter._getTextureInfo(babylonMaterial.clearCoat.textureRoughness);\r\n                }\r\n\r\n                if (babylonMaterial.clearCoat.isTintEnabled) {\r\n                    Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);\r\n                }\r\n\r\n                if (babylonMaterial.clearCoat.remapF0OnInterfaceChange) {\r\n                    Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);\r\n                }\r\n\r\n                const clearCoatNormalTextureInfo = this._exporter._glTFMaterialExporter._getTextureInfo(babylonMaterial.clearCoat.bumpTexture);\r\n\r\n                const clearCoatInfo: IKHRMaterialsClearcoat = {\r\n                    clearcoatFactor: babylonMaterial.clearCoat.intensity,\r\n                    clearcoatTexture: clearCoatTextureInfo ?? undefined,\r\n                    clearcoatRoughnessFactor: babylonMaterial.clearCoat.roughness,\r\n                    clearcoatRoughnessTexture: clearCoatTextureRoughnessInfo ?? undefined,\r\n                    clearcoatNormalTexture: clearCoatNormalTextureInfo ?? undefined,\r\n                    hasTextures: () => {\r\n                        return clearCoatInfo.clearcoatTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null;\r\n                    },\r\n                };\r\n\r\n                node.extensions[NAME] = clearCoatInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_materials_clearcoat(exporter));\r\n","import type { IMaterial, IKHRMaterialsIridescence } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_iridescence\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_iridescence implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: _Exporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.iridescence.isEnabled) {\r\n                if (babylonMaterial.iridescence.texture) {\r\n                    additionalTextures.push(babylonMaterial.iridescence.texture);\r\n                }\r\n                if (babylonMaterial.iridescence.thicknessTexture && babylonMaterial.iridescence.thicknessTexture !== babylonMaterial.iridescence.texture) {\r\n                    additionalTextures.push(babylonMaterial.iridescence.thicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.iridescence.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const iridescenceTextureInfo = this._exporter._glTFMaterialExporter._getTextureInfo(babylonMaterial.iridescence.texture);\r\n                const iridescenceThicknessTextureInfo = this._exporter._glTFMaterialExporter._getTextureInfo(babylonMaterial.iridescence.thicknessTexture);\r\n\r\n                const iridescenceInfo: IKHRMaterialsIridescence = {\r\n                    iridescenceFactor: babylonMaterial.iridescence.intensity,\r\n                    iridescenceIor: babylonMaterial.iridescence.indexOfRefraction,\r\n                    iridescenceThicknessMinimum: babylonMaterial.iridescence.minimumThickness,\r\n                    iridescenceThicknessMaximum: babylonMaterial.iridescence.maximumThickness,\r\n\r\n                    iridescenceTexture: iridescenceTextureInfo ?? undefined,\r\n                    iridescenceThicknessTexture: iridescenceThicknessTextureInfo ?? undefined,\r\n                    hasTextures: () => {\r\n                        return iridescenceInfo.iridescenceTexture !== null || iridescenceInfo.iridescenceThicknessTexture !== null;\r\n                    },\r\n                };\r\n\r\n                node.extensions[NAME] = iridescenceInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_materials_iridescence(exporter));\r\n","import type { IMaterial, IKHRMaterialsAnisotropy } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_anisotropy\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_anisotropy implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: _Exporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.anisotropy.isEnabled && !babylonMaterial.anisotropy.legacy) {\r\n                if (babylonMaterial.anisotropy.texture) {\r\n                    additionalTextures.push(babylonMaterial.anisotropy.texture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.anisotropy.isEnabled || babylonMaterial.anisotropy.legacy) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const anisotropyTextureInfo = this._exporter._glTFMaterialExporter._getTextureInfo(babylonMaterial.anisotropy.texture);\r\n\r\n                const anisotropyInfo: IKHRMaterialsAnisotropy = {\r\n                    anisotropyStrength: babylonMaterial.anisotropy.intensity,\r\n                    anisotropyRotation: babylonMaterial.anisotropy.angle,\r\n                    anisotropyTexture: anisotropyTextureInfo ?? undefined,\r\n                    hasTextures: () => {\r\n                        return anisotropyInfo.anisotropyTexture !== null;\r\n                    },\r\n                };\r\n\r\n                node.extensions[NAME] = anisotropyInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_materials_anisotropy(exporter));\r\n","import type { IMaterial, IKHRMaterialsSheen } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_sheen\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_sheen implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    private _exporter: _Exporter;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (babylonMaterial.sheen.isEnabled && babylonMaterial.sheen.texture) {\r\n                return [babylonMaterial.sheen.texture];\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public postExportMaterialAsync(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial) {\r\n                if (!babylonMaterial.sheen.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                if (node.extensions == null) {\r\n                    node.extensions = {};\r\n                }\r\n                const sheenInfo: IKHRMaterialsSheen = {\r\n                    sheenColorFactor: babylonMaterial.sheen.color.asArray(),\r\n                    sheenRoughnessFactor: babylonMaterial.sheen.roughness ?? 0,\r\n                    hasTextures: () => {\r\n                        return sheenInfo.sheenColorTexture !== null || sheenInfo.sheenRoughnessTexture !== null;\r\n                    },\r\n                };\r\n\r\n                if (babylonMaterial.sheen.texture) {\r\n                    sheenInfo.sheenColorTexture = this._exporter._glTFMaterialExporter._getTextureInfo(babylonMaterial.sheen.texture) ?? undefined;\r\n                }\r\n\r\n                if (babylonMaterial.sheen.textureRoughness && !babylonMaterial.sheen.useRoughnessFromMainTexture) {\r\n                    sheenInfo.sheenRoughnessTexture = this._exporter._glTFMaterialExporter._getTextureInfo(babylonMaterial.sheen.textureRoughness) ?? undefined;\r\n                } else if (babylonMaterial.sheen.texture && babylonMaterial.sheen.useRoughnessFromMainTexture) {\r\n                    sheenInfo.sheenRoughnessTexture = this._exporter._glTFMaterialExporter._getTextureInfo(babylonMaterial.sheen.texture) ?? undefined;\r\n                }\r\n\r\n                node.extensions[NAME] = sheenInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_materials_sheen(exporter));\r\n","import type { IMaterial } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\nconst NAME = \"KHR_materials_unlit\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_unlit implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            let unlitMaterial = false;\r\n\r\n            if (babylonMaterial instanceof PBRMaterial) {\r\n                unlitMaterial = babylonMaterial.unlit;\r\n            } else if (babylonMaterial instanceof StandardMaterial) {\r\n                unlitMaterial = babylonMaterial.disableLighting;\r\n            }\r\n\r\n            if (unlitMaterial) {\r\n                this._wasUsed = true;\r\n\r\n                if (node.extensions == null) {\r\n                    node.extensions = {};\r\n                }\r\n\r\n                node.extensions[NAME] = {};\r\n            }\r\n\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, () => new KHR_materials_unlit());\r\n","import type { IMaterial, IKHRMaterialsIor } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\n\r\nconst NAME = \"KHR_materials_ior\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_ior implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        return mat.indexOfRefraction != undefined && mat.indexOfRefraction != 1.5; // 1.5 is normative default value.\r\n    }\r\n\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const iorInfo: IKHRMaterialsIor = {\r\n                    ior: babylonMaterial.indexOfRefraction,\r\n                };\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = iorInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_materials_ior());\r\n","import type { IMaterial, IKHRMaterialsSpecular } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_specular\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_specular implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: _Exporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (this._isExtensionEnabled(babylonMaterial)) {\r\n                if (babylonMaterial.metallicReflectanceTexture) {\r\n                    additionalTextures.push(babylonMaterial.metallicReflectanceTexture);\r\n                }\r\n                if (babylonMaterial.reflectanceTexture) {\r\n                    additionalTextures.push(babylonMaterial.reflectanceTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        return (\r\n            (mat.metallicF0Factor != undefined && mat.metallicF0Factor != 1.0) ||\r\n            (mat.metallicReflectanceColor != undefined && !mat.metallicReflectanceColor.equalsFloats(1.0, 1.0, 1.0)) ||\r\n            this._hasTexturesExtension(mat)\r\n        );\r\n    }\r\n\r\n    private _hasTexturesExtension(mat: PBRMaterial): boolean {\r\n        return mat.metallicReflectanceTexture != null || mat.reflectanceTexture != null;\r\n    }\r\n\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const metallicReflectanceTexture = this._exporter._glTFMaterialExporter._getTextureInfo(babylonMaterial.metallicReflectanceTexture) ?? undefined;\r\n                const reflectanceTexture = this._exporter._glTFMaterialExporter._getTextureInfo(babylonMaterial.reflectanceTexture) ?? undefined;\r\n                const metallicF0Factor = babylonMaterial.metallicF0Factor == 1.0 ? undefined : babylonMaterial.metallicF0Factor;\r\n                const metallicReflectanceColor = babylonMaterial.metallicReflectanceColor.equalsFloats(1.0, 1.0, 1.0)\r\n                    ? undefined\r\n                    : babylonMaterial.metallicReflectanceColor.asArray();\r\n\r\n                const specularInfo: IKHRMaterialsSpecular = {\r\n                    specularFactor: metallicF0Factor,\r\n                    specularTexture: metallicReflectanceTexture,\r\n                    specularColorFactor: metallicReflectanceColor,\r\n                    specularColorTexture: reflectanceTexture,\r\n                    hasTextures: () => {\r\n                        return this._hasTexturesExtension(babylonMaterial);\r\n                    },\r\n                };\r\n                node.extensions[NAME] = specularInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_materials_specular(exporter));\r\n","import type { IMaterial, IKHRMaterialsVolume } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\n\r\nconst NAME = \"KHR_materials_volume\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_volume implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: _Exporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (this._isExtensionEnabled(babylonMaterial)) {\r\n                if (babylonMaterial.subSurface.thicknessTexture) {\r\n                    additionalTextures.push(babylonMaterial.subSurface.thicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        // this extension requires either the KHR_materials_transmission or KHR_materials_translucency extensions.\r\n        if (!subs.isRefractionEnabled && !subs.isTranslucencyEnabled) {\r\n            return false;\r\n        }\r\n        return (\r\n            (subs.maximumThickness != undefined && subs.maximumThickness != 0) ||\r\n            (subs.tintColorAtDistance != undefined && subs.tintColorAtDistance != Number.POSITIVE_INFINITY) ||\r\n            (subs.tintColor != undefined && subs.tintColor != Color3.White()) ||\r\n            this._hasTexturesExtension(mat)\r\n        );\r\n    }\r\n\r\n    private _hasTexturesExtension(mat: PBRMaterial): boolean {\r\n        return mat.subSurface.thicknessTexture != null;\r\n    }\r\n\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const subs = babylonMaterial.subSurface;\r\n                const thicknessFactor = subs.maximumThickness == 0 ? undefined : subs.maximumThickness;\r\n                const thicknessTexture = this._exporter._glTFMaterialExporter._getTextureInfo(subs.thicknessTexture) ?? undefined;\r\n                const attenuationDistance = subs.tintColorAtDistance == Number.POSITIVE_INFINITY ? undefined : subs.tintColorAtDistance;\r\n                const attenuationColor = subs.tintColor.equalsFloats(1.0, 1.0, 1.0) ? undefined : subs.tintColor.asArray();\r\n\r\n                const volumeInfo: IKHRMaterialsVolume = {\r\n                    thicknessFactor: thicknessFactor,\r\n                    thicknessTexture: thicknessTexture,\r\n                    attenuationDistance: attenuationDistance,\r\n                    attenuationColor: attenuationColor,\r\n                    hasTextures: () => {\r\n                        return this._hasTexturesExtension(babylonMaterial);\r\n                    },\r\n                };\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = volumeInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_materials_volume(exporter));\r\n","import type { IMaterial, IKHRMaterialsTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_transmission\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_transmission implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: _Exporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (this._isExtensionEnabled(babylonMaterial)) {\r\n                if (babylonMaterial.subSurface.thicknessTexture) {\r\n                    additionalTextures.push(babylonMaterial.subSurface.thicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        return (subs.isRefractionEnabled && subs.refractionIntensity != undefined && subs.refractionIntensity != 0) || this._hasTexturesExtension(mat);\r\n    }\r\n\r\n    private _hasTexturesExtension(mat: PBRMaterial): boolean {\r\n        return mat.subSurface.refractionIntensityTexture != null;\r\n    }\r\n\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const subs = babylonMaterial.subSurface;\r\n                const transmissionFactor = subs.refractionIntensity === 0 ? undefined : subs.refractionIntensity;\r\n\r\n                const transmissionTexture = this._exporter._glTFMaterialExporter._getTextureInfo(subs.refractionIntensityTexture) ?? undefined;\r\n\r\n                const volumeInfo: IKHRMaterialsTransmission = {\r\n                    transmissionFactor: transmissionFactor,\r\n                    transmissionTexture: transmissionTexture,\r\n                    hasTextures: () => {\r\n                        return this._hasTexturesExtension(babylonMaterial);\r\n                    },\r\n                };\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = volumeInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_materials_transmission(exporter));\r\n","import type { IBufferView, IAccessor, INode, IEXTMeshGpuInstancing } from \"babylonjs-gltf2interface\";\r\nimport { AccessorType, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport type { _BinaryWriter } from \"../glTFExporter\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Node } from \"core/node\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport \"core/Meshes/thinInstanceMesh\";\r\nimport { TmpVectors, Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\n\r\nconst NAME = \"EXT_mesh_gpu_instancing\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_mesh_gpu_instancing implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: _Exporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportNodeAsync(\r\n        context: string,\r\n        node: Nullable<INode>,\r\n        babylonNode: Node,\r\n        nodeMap: { [key: number]: number },\r\n        binaryWriter: _BinaryWriter\r\n    ): Promise<Nullable<INode>> {\r\n        return new Promise((resolve) => {\r\n            if (node && babylonNode instanceof Mesh) {\r\n                if (babylonNode.hasThinInstances && binaryWriter) {\r\n                    this._wasUsed = true;\r\n\r\n                    const noTranslation = Vector3.Zero();\r\n                    const noRotation = Quaternion.Identity();\r\n                    const noScale = Vector3.One();\r\n\r\n                    // retrieve all the instance world matrix\r\n                    const matrix = babylonNode.thinInstanceGetWorldMatrices();\r\n\r\n                    const iwt = TmpVectors.Vector3[2];\r\n                    const iwr = TmpVectors.Quaternion[1];\r\n                    const iws = TmpVectors.Vector3[3];\r\n\r\n                    let hasAnyInstanceWorldTranslation = false;\r\n                    let hasAnyInstanceWorldRotation = false;\r\n                    let hasAnyInstanceWorldScale = false;\r\n\r\n                    // prepare temp buffers\r\n                    const translationBuffer = new Float32Array(babylonNode.thinInstanceCount * 3);\r\n                    const rotationBuffer = new Float32Array(babylonNode.thinInstanceCount * 4);\r\n                    const scaleBuffer = new Float32Array(babylonNode.thinInstanceCount * 3);\r\n\r\n                    let i = 0;\r\n                    for (const m of matrix) {\r\n                        m.decompose(iws, iwr, iwt);\r\n\r\n                        // fill the temp buffer\r\n                        translationBuffer.set(iwt.asArray(), i * 3);\r\n                        rotationBuffer.set(iwr.normalize().asArray(), i * 4); // ensure the quaternion is normalized\r\n                        scaleBuffer.set(iws.asArray(), i * 3);\r\n\r\n                        // this is where we decide if there is any transformation\r\n                        hasAnyInstanceWorldTranslation = hasAnyInstanceWorldTranslation || !iwt.equalsWithEpsilon(noTranslation);\r\n                        hasAnyInstanceWorldRotation = hasAnyInstanceWorldRotation || !iwr.equalsWithEpsilon(noRotation);\r\n                        hasAnyInstanceWorldScale = hasAnyInstanceWorldScale || !iws.equalsWithEpsilon(noScale);\r\n\r\n                        i++;\r\n                    }\r\n\r\n                    const extension: IEXTMeshGpuInstancing = {\r\n                        attributes: {},\r\n                    };\r\n\r\n                    // do we need to write TRANSLATION ?\r\n                    if (hasAnyInstanceWorldTranslation) {\r\n                        extension.attributes[\"TRANSLATION\"] = this._buildAccessor(\r\n                            translationBuffer,\r\n                            AccessorType.VEC3,\r\n                            babylonNode.thinInstanceCount,\r\n                            binaryWriter,\r\n                            AccessorComponentType.FLOAT\r\n                        );\r\n                    }\r\n                    // do we need to write ROTATION ?\r\n                    if (hasAnyInstanceWorldRotation) {\r\n                        const componentType = AccessorComponentType.FLOAT; // we decided to stay on FLOAT for now see https://github.com/BabylonJS/Babylon.js/pull/12495\r\n                        extension.attributes[\"ROTATION\"] = this._buildAccessor(rotationBuffer, AccessorType.VEC4, babylonNode.thinInstanceCount, binaryWriter, componentType);\r\n                    }\r\n                    // do we need to write SCALE ?\r\n                    if (hasAnyInstanceWorldScale) {\r\n                        extension.attributes[\"SCALE\"] = this._buildAccessor(\r\n                            scaleBuffer,\r\n                            AccessorType.VEC3,\r\n                            babylonNode.thinInstanceCount,\r\n                            binaryWriter,\r\n                            AccessorComponentType.FLOAT\r\n                        );\r\n                    }\r\n\r\n                    /* eslint-enable @typescript-eslint/naming-convention*/\r\n                    node.extensions = node.extensions || {};\r\n                    node.extensions[NAME] = extension;\r\n                }\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n\r\n    private _buildAccessor(buffer: Float32Array, type: AccessorType, count: number, binaryWriter: _BinaryWriter, componentType: AccessorComponentType): number {\r\n        // write the buffer\r\n        const bufferOffset = binaryWriter.getByteOffset();\r\n        switch (componentType) {\r\n            case AccessorComponentType.FLOAT: {\r\n                for (let i = 0; i != buffer.length; i++) {\r\n                    binaryWriter.setFloat32(buffer[i]);\r\n                }\r\n                break;\r\n            }\r\n            case AccessorComponentType.BYTE: {\r\n                for (let i = 0; i != buffer.length; i++) {\r\n                    binaryWriter.setByte(buffer[i] * 127);\r\n                }\r\n                break;\r\n            }\r\n            case AccessorComponentType.SHORT: {\r\n                for (let i = 0; i != buffer.length; i++) {\r\n                    binaryWriter.setInt16(buffer[i] * 32767);\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n        // build the buffer view\r\n        const bv: IBufferView = { buffer: 0, byteOffset: bufferOffset, byteLength: buffer.length * VertexBuffer.GetTypeByteLength(componentType) };\r\n        const bufferViewIndex = this._exporter._bufferViews.length;\r\n        this._exporter._bufferViews.push(bv);\r\n\r\n        // finally build the accessor\r\n        const accessorIndex = this._exporter._accessors.length;\r\n        const accessor: IAccessor = {\r\n            bufferView: bufferViewIndex,\r\n            componentType: componentType,\r\n            count: count,\r\n            type: type,\r\n            normalized: componentType == AccessorComponentType.BYTE || componentType == AccessorComponentType.SHORT,\r\n        };\r\n        this._exporter._accessors.push(accessor);\r\n        return accessorIndex;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n_Exporter.RegisterExtension(NAME, (exporter) => new EXT_mesh_gpu_instancing(exporter));\r\n","import type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { IMaterial, IKHRMaterialsEmissiveStrength } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_emissive_strength\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_emissive_strength implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    public dispose() {}\r\n\r\n    /** @interal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAsync(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (!(babylonMaterial instanceof PBRMaterial)) {\r\n                return resolve(node);\r\n            }\r\n\r\n            const emissiveColor = babylonMaterial.emissiveColor.asArray();\r\n            const tempEmissiveStrength = Math.max(...emissiveColor);\r\n\r\n            if (tempEmissiveStrength > 1) {\r\n                this._wasUsed = true;\r\n\r\n                node.extensions ||= {};\r\n\r\n                const emissiveStrengthInfo: IKHRMaterialsEmissiveStrength = {\r\n                    emissiveStrength: tempEmissiveStrength,\r\n                };\r\n\r\n                // Normalize each value of the emissive factor to have a max value of 1\r\n                const newEmissiveFactor = babylonMaterial.emissiveColor.scale(1 / emissiveStrengthInfo.emissiveStrength);\r\n\r\n                node.emissiveFactor = newEmissiveFactor.asArray();\r\n                node.extensions[NAME] = emissiveStrengthInfo;\r\n            }\r\n\r\n            return resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_materials_emissive_strength());\r\n","import type { ImageMimeType, IMeshPrimitive, INode, IMaterial, ITextureInfo } from \"babylonjs-gltf2interface\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { IDisposable } from \"core/scene\";\r\n\r\nimport type { _BinaryWriter } from \"./glTFExporter\";\r\nimport type { IGLTFExporterExtension } from \"../glTFFileExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\n/** @internal */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var __IGLTFExporterExtensionV2 = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for a glTF exporter extension\r\n * @internal\r\n */\r\nexport interface IGLTFExporterExtensionV2 extends IGLTFExporterExtension, IDisposable {\r\n    /**\r\n     * Define this method to modify the default behavior before exporting a texture\r\n     * @param context The context when loading the asset\r\n     * @param babylonTexture The Babylon.js texture\r\n     * @param mimeType The mime-type of the generated image\r\n     * @returns A promise that resolves with the exported texture\r\n     */\r\n    preExportTextureAsync?(context: string, babylonTexture: Nullable<Texture>, mimeType: ImageMimeType): Promise<Nullable<Texture>>;\r\n\r\n    /**\r\n     * Define this method to get notified when a texture info is created\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info\r\n     * @param babylonTexture The Babylon.js texture\r\n     */\r\n    postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: BaseTexture): void;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when exporting texture info\r\n     * @param context The context when loading the asset\r\n     * @param meshPrimitive glTF mesh primitive\r\n     * @param babylonSubMesh Babylon submesh\r\n     * @param binaryWriter glTF serializer binary writer instance\r\n     * @returns nullable IMeshPrimitive promise\r\n     */\r\n    postExportMeshPrimitiveAsync?(context: string, meshPrimitive: Nullable<IMeshPrimitive>, babylonSubMesh: SubMesh, binaryWriter: _BinaryWriter): Promise<IMeshPrimitive>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a node\r\n     * @param context The context when exporting the node\r\n     * @param node glTF node\r\n     * @param babylonNode BabylonJS node\r\n     * @returns nullable INode promise\r\n     */\r\n    postExportNodeAsync?(context: string, node: Nullable<INode>, babylonNode: Node, nodeMap: { [key: number]: number }, binaryWriter: _BinaryWriter): Promise<Nullable<INode>>;\r\n\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a material\r\n     * @param material glTF material\r\n     * @param babylonMaterial BabylonJS material\r\n     * @returns nullable IMaterial promise\r\n     */\r\n    postExportMaterialAsync?(context: string, node: Nullable<IMaterial>, babylonMaterial: Material): Promise<IMaterial>;\r\n\r\n    /**\r\n     * Define this method to return additional textures to export from a material\r\n     * @param material glTF material\r\n     * @param babylonMaterial BabylonJS material\r\n     * @returns List of textures\r\n     */\r\n    postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[];\r\n\r\n    /** Gets a boolean indicating that this extension was used */\r\n    wasUsed: boolean;\r\n\r\n    /** Gets a boolean indicating that this extension is required for the file to work */\r\n    required: boolean;\r\n\r\n    /**\r\n     * Called after the exporter state changes to EXPORTING\r\n     */\r\n    onExporting?(): void;\r\n}\r\n","/* eslint-disable import/no-internal-modules */\r\nimport * as Exporters from \"serializers/glTF/glTFFileExporter\";\r\nimport * as Datas from \"serializers/glTF/2.0/glTFData\";\r\nimport * as Serializers from \"serializers/glTF/2.0/glTFSerializer\";\r\nimport * as Extensions from \"serializers/glTF/2.0/Extensions/index\";\r\nimport * as GLTF2 from \"serializers/glTF/2.0/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof globalObject !== \"undefined\") {\r\n    (<any>globalObject).BABYLON = (<any>globalObject).BABYLON || {};\r\n    const BABYLON = (<any>globalObject).BABYLON;\r\n    BABYLON.GLTF2 = BABYLON.GLTF2 || {};\r\n    BABYLON.GLTF2.Exporter = BABYLON.GLTF2.Exporter || {};\r\n    BABYLON.GLTF2.Exporter.Extensions = BABYLON.GLTF2.Exporter.Extensions || {};\r\n\r\n    const keys = [];\r\n    for (const key in Exporters) {\r\n        BABYLON[key] = (<any>Exporters)[key];\r\n        keys.push(key);\r\n    }\r\n    for (const key in Datas) {\r\n        BABYLON[key] = (<any>Datas)[key];\r\n        keys.push(key);\r\n    }\r\n    for (const key in Serializers) {\r\n        BABYLON[key] = (<any>Serializers)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (const key in Extensions) {\r\n        BABYLON.GLTF2.Exporter.Extensions[key] = (<any>Extensions)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (const key in GLTF2) {\r\n        // Prevent Reassignment.\r\n        if (keys.indexOf(key) > -1) {\r\n            continue;\r\n        }\r\n\r\n        BABYLON.GLTF2.Exporter[key] = (<any>GLTF2)[key];\r\n    }\r\n}\r\n\r\nexport * from \"serializers/glTF/glTFFileExporter\";\r\nexport * from \"serializers/glTF/2.0/index\";\r\n","import * as serializers from \"@lts/serializers/legacy/legacy-glTF2Serializer\";\r\nexport { serializers };\r\nexport default serializers;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__520__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","__IGLTFExporterExtension","glTFFiles","downloadFiles","endsWith","str","suffix","indexOf","length","link","document","createElement","body","appendChild","setAttribute","download","blob","mimeType","type","href","URL","createObjectURL","Blob","click","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","result","done","then","apply","__generator","f","y","t","_","label","sent","trys","ops","verb","iterator","n","v","op","TypeError","pop","push","__spreadArray","to","from","pack","arguments","ar","i","l","Array","slice","concat","create","SuppressedError","_TangentType","exporter","_textureMap","_internalTextureToImage","_exporter","_FuzzyEquals","color1","color2","epsilon","Scalar","WithinEpsilon","b","_convertMaterialsToGLTFAsync","exportMaterials","hasTextureCoords","promises","forEach","material","getClassName","_convertStandardMaterialAsync","_convertPBRMaterialAsync","Tools","Warn","name","all","_stripTexturesFromMaterial","originalMaterial","newMaterial","doubleSided","alphaMode","alphaCutoff","emissiveFactor","originalPBRMetallicRoughness","pbrMetallicRoughness","baseColorFactor","metallicFactor","roughnessFactor","_hasTexturesPresent","emissiveTexture","normalTexture","occlusionTexture","pbrMat","baseColorTexture","metallicRoughnessTexture","extensions","extension","extensionObject","hasTextures","_getTextureInfo","babylonTexture","textureUid","uid","_convertToGLTFPBRMetallicRoughness","babylonStandardMaterial","specularPower","p0","p1","p2","p3","P0","Vector2","P1","P2","P3","diffuse","diffuseColor","toLinearSpace","getScene","getEngine","useExactSrgbConversions","scale","opacity","alpha","roughness","Clamp","_GLTFMaterialExporter","_MaxSpecularPower","Math","pow","x","_SolveMetallic","specular","oneMinusSpecularStrength","_DielectricSpecular","a","D","sqrt","_SetAlphaMode","glTFMaterial","babylonMaterial","needAlphaBlending","needAlphaTesting","alphaCutOff","materialMap","_materialMap","materials","_materials","backFaceCulling","twoSidedLighting","diffuseTexture","_exportTextureAsync","textureInfo","bumpTexture","level","ambientTexture","index","opacityTexture","Constants","ALPHA_COMBINE","toString","emissiveColor","Color3","Black","_Epsilon","asArray","uniqueId","_finishMaterial","tasks","_extensionsPostExportMaterialAdditionalTextures","texture","extensionWork","_extensionsPostExportMaterialAsync","_getImageDataAsync","buffer","width","height","textureType","TEXTURETYPE_UNSIGNED_INT","hostingScene","_babylonScene","engine","tempTexture","createRawTexture","TEXTUREFORMAT_RGBA","Texture","NEAREST_SAMPLINGMODE","TextureTools","ApplyPostProcess","TEXTURE_NEAREST_SAMPLINGMODE","_readTexturePixels","data","DumpTools","DumpDataAsync","_createWhiteTexture","scene","Uint8Array","RawTexture","CreateRGBATexture","_resizeTexturesToSameDimensions","texture1","texture2","resizedTexture1","resizedTexture2","texture1Size","getSize","texture2Size","CreateResizedCopy","_convertPixelArrayToFloat32","pixels","Float32Array","Error","_convertSpecularGlossinessTexturesToMetallicRoughnessAsync","specularGlossinessTexture","factors","resizedTextures","diffuseSize","diffuseBuffer","specularGlossinessBuffer","readPixels","diffusePixels","specularPixels","byteLength","metallicRoughnessBuffer","baseColorBuffer","maxBaseColor","maxMetallic","maxRoughness","h","w","offset","multiply","specularColor","glossiness","specularGlossiness","metallicRoughness","_convertSpecularGlossinessToMetallicRoughness","max","baseColor","metallic","hasAlpha","writeOutMetallicRoughnessTexture","writeOutBaseColorTexture","destinationOffset","linearBaseColorPixel","FromInts","sRGBBaseColorPixel","toGammaSpace","White","metallicRoughnessPixel","metallicRoughnessTextureData","baseColorTextureData","diffusePerceivedBrightness","_getPerceivedBrightness","specularPerceivedBrightness","_getMaxComponent","baseColorFromDiffuse","baseColorFromSpecular","subtract","Lerp","clampToRef","color","_convertMetalRoughFactorsToMetallicRoughnessAsync","babylonPBRMaterial","glTFPbrMetallicRoughness","_albedoColor","_metallic","_roughness","_albedoTexture","glTFTexture","metallicTexture","_metallicTexture","_getTextureSampler","sampler","wrapS","_getGLTFTextureWrapMode","wrapU","wrapT","wrapV","samplingMode","LINEAR_LINEAR","magFilter","minFilter","LINEAR_NEAREST","NEAREST_LINEAR","NEAREST_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","NEAREST_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","LINEAR_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPNEAREST","wrapMode","WRAP_ADDRESSMODE","CLAMP_ADDRESSMODE","MIRROR_ADDRESSMODE","_convertSpecGlossFactorsToMetallicRoughnessAsync","specGloss","_reflectivityColor","_microSurface","albedoTexture","reflectivityTexture","_reflectivityTexture","useMicrosurfaceFromReflectivityMapAlpha","_useMicroSurfaceFromReflectivityMapAlpha","_exportTextureSampler","metallicRoughnessFactors","textures","_textures","imageIndex","_exportImage","_exportTextureInfo","coordinatesIndex","isMetallicWorkflow","albedoColor","_setMetallicRoughnessPbrMaterial","_twoSidedLighting","_bumpTexture","promise","_ambientTexture","texCoord","ambientTextureStrength","_ambientTextureStrength","strength","_emissiveTexture","_emissiveColor","_getPixelsFromTexture","extensionPromise","_extensionsPreExportTextureAsync","_exportTextureInfoAsync","samplerIndex","textureMimeType","internalTextureToImage","internalTextureUniqueId","getInternalTexture","imageIndexPromise","_extensionsPostExportTextures","imageData","_imageData","baseName","replace","getFileExtensionFromMimeType","fileName","RandomId","images","_images","uri","textureIndex","findIndex","source","samplers","_samplers","s","_CreateBufferView","bufferIndex","byteOffset","byteStride","bufferview","_CreateAccessor","bufferviewIndex","componentType","count","min","accessor","bufferView","_CalculateMinMaxPositions","positions","vertexStart","vertexCount","indexOffset","vector","Infinity","Vector3","FromArray","j","num","_NormalizeTangentFromRef","tangent","z","_GetDataAccessorElementCount","accessorType","_IsTransformable","babylonNode","TransformNode","Camera","Light","_CreateNodeAnimation","babylonTransformNode","animation","animationChannelTargetPath","useQuaternion","animationSampleRate","inputs","outputs","keyFrames","getKeys","minMaxKeyFrames","_GLTFAnimation","_CalculateMinMaxKeyFrames","interpolationOrBake","_DeduceInterpolation","interpolation","interpolationType","shouldBakeAnimation","_CreateBakedAnimation","framePerSecond","_CreateLinearOrStepAnimation","_CreateCubicSplineAnimation","samplerInterpolation","inputsMin","FloatRound","inputsMax","_DeduceAnimationInfo","dataAccessorType","property","targetProperty","split","_CreateNodeAnimationFromNodeAnimations","runtimeGLTFAnimation","idleGLTFAnimations","nodeMap","nodes","binaryWriter","bufferViews","accessors","shouldExportAnimation","glTFAnimation","animations","animationInfo","channels","_AddAnimation","hasRunningRuntimeAnimations","_CreateMorphTargetAnimationFromMorphTargetAnimations","Mesh","morphTargetManager","numTargets","getTarget","combinedAnimation","Animation","dataType","loopMode","enableBlending","combinedAnimationKeys","animationKeys","animationKey","k","frame","setKeys","_CreateNodeAndMorphAnimationFromAnimationGroups","babylonScene","glTFAnimations","animationGroups","animationGroup","morphAnimations","Map","sampleAnimations","morphAnimationMeshes","Set","animationGroupFrameDiff","targetAnimation","targetedAnimations","target","MorphTarget","morphTargetManagers","find","babylonMesh","meshes","mesh","has","set","add","combinedAnimationGroup","sampleAnimationKeys","numAnimationKeys","morphTarget","animationsByMorphTarget","morphTargetAnimation","ANIMATIONTYPE_FLOAT","influence","inTangent","outTangent","morphAnimationChannels","keyframeAccessorIndex","dataAccessorIndex","outputLength","animationSampler","animationChannel","animationData","currentInput","newInputs","shift","nodeIndex","_GLTFUtilities","getByteOffset","input","setFloat32","output","entry","node","path","minFrame","maxFrame","fps","sampleRate","minMaxFrames","time","quaternionCache","Quaternion","Identity","previousTime","maxUsedFrame","currKeyFrame","nextKeyFrame","prevKeyFrame","endFrame","equals","state","repeatCount","_interpolate","_SetInterpolatedValue","_ConvertFactorToVector3OrQuaternion","factor","basePositionRotationOrScale","_GetBasePositionRotationOrScale","componentName","normalize","cacheValue","RotationYawPitchRollToRef","keyFrame","_AddKeyframeValue","_AddSplineTangent","INTANGENT","OUTTANGENT","q","rotationQuaternion","rotation","Zero","p","position","scaling","One","newPositionRotationOrScale","animationType","ANIMATIONTYPE_VECTOR3","array","RotationYawPitchRoll","posRotScale","ANIMATIONTYPE_QUATERNION","AnimationKeyInterpolation","STEP","tangentType","tangentValue","convertHandednessMatrix","Matrix","Compose","isNoopNode","useRightHandedSystem","getWorldMatrix","isIdentity","multiplyToRef","TmpVectors","geometry","InstancedMesh","sourceMesh","options","_extensions","_glTF","asset","Engine","Version","version","EngineStore","LastCreatedScene","_bufferViews","_accessors","_meshes","_scenes","_cameras","_nodes","_skins","_animations","_orderedImageData","_options","_animationSampleRate","_glTFMaterialExporter","_loadExtensions","_applyExtension","actionAsync","currentPromise","newNode","_applyExtensions","_Exporter","_ExtensionNames","context","preExportTextureAsync","_extensionsPostExportMeshPrimitiveAsync","meshPrimitive","babylonSubMesh","postExportMeshPrimitiveAsync","_extensionsPostExportNodeAsync","postExportNodeAsync","postExportMaterialAsync","postExportMaterialAdditionalTextures","postExportTexture","_forEachExtensions","action","enabled","_extensionsOnExporting","wasUsed","extensionsUsed","required","extensionsRequired","onExporting","_ExtensionFactories","dispose","extensionKey","RegisterExtension","UnregisterExtension","splice","_reorderIndicesBasedOnPrimitiveMode","submesh","primitiveMode","babylonIndices","Material","TriangleFillMode","indexStart","indexCount","secondIndex","getUInt32","thirdIndex","setUInt32","TriangleFanDrawMode","start","TriangleStripDrawMode","_reorderVertexAttributeDataBasedOnPrimitiveMode","vertexBufferKind","meshAttributeArray","_reorderTriangleFillMode","_reorderTriangleStripDrawMode","_reorderTriangleFanMode","vertexBuffer","_getVertexBufferFromMesh","getMesh","stride","VertexBuffer","GetTypeByteLength","verticesCount","vertexData","PositionKind","NormalKind","verticesStart","TangentKind","Vector4","ColorKind","size","UVKind","UV2Kind","_writeVertexAttributeData","vertices","vertexAttributeKind","vertex","component","_writeAttributeData","attributeComponentKind","writeBinaryFunc","vertexAttributes","meshMaterial","convertToLinear","Color4","FromArrayToRef","toLinearSpaceToRef","MatricesIndicesKind","MatricesIndicesExtraKind","MatricesWeightsKind","MatricesWeightsExtraKind","setUInt8","bind","setUInt16","writeMorphTargetAttributeData","morphTargetAttributeArray","minMax","difference","difference4","morphData","subtractToRef","copyFromFloats","_generateJSON","shouldUseGlb","glTFPrefix","prettyPrint","imageName","_totalByteLength","buffers","scenes","cameras","skins","image","JSON","stringify","_generateGLTFAsync","_generateBinaryAsync","binaryBuffer","jsonText","bin","glTFFileName","glTFBinFile","container","GLTFData","_BinaryWriter","_createSceneAsync","_localEngine","getArrayBuffer","_getPadding","remainder","_generateGLBAsync","encodedJsonText","glbFileName","jsonLength","imageByteLength","TextEncoder","encode","jsonPadding","binPadding","imagePadding","headerLength","headerBuffer","ArrayBuffer","headerBufferView","DataView","setUint32","jsonChunkBuffer","jsonChunkBufferView","jsonData","blankCharCode","charCodeAt","charCode","codePointAt","jsonPaddingView","binaryChunkBuffer","binaryChunkBufferView","binPaddingBuffer","binPaddingView","imagePaddingBuffer","imagePaddingView","glbData","glbFile","_setNodeTransformation","getPivotPoint","equalsToFloats","translation","multiplyInPlace","IsIdentity","_setCameraTransformation","babylonCamera","attributeKind","bufferMesh","isVerticesDataPresent","getVertexBuffer","_createBufferViewKind","kind","getVerticesData","typeByteLength","_setMorphTargetAttributes","babylonMorphTarget","targets","hasNormals","vertexNormals","morphNormals","getNormals","bufferViewIndex","NORMAL","hasPositions","vertexPositions","morphPositions","getPositions","POSITION","hasTangents","vertexTangents","morphTangents","getTangents","TANGENT","_getMeshPrimitiveMode","LinesMesh","LineListDrawMode","baseMesh","overrideRenderingFillMode","fillMode","_setPrimitiveMode","mode","PointListDrawMode","PointFillMode","LineLoopDrawMode","LineStripDrawMode","_setAttributeKind","attributes","COLOR_0","TEXCOORD_0","TEXCOORD_1","JOINTS_0","JOINTS_1","WEIGHTS_0","WEIGHTS_1","_setPrimitiveAttributesAsync","attributeData","accessorComponentType","indexBufferViewIndex","vertexAttributeBufferViews","attribute","DeduceStride","getTotalIndices","indices","getIndices","subMeshes","getMaterial","defaultMaterial","materialIndex","MultiMaterial","subMaterial","subMaterials","exportUnusedUVs","keys","overrideMaterialSideOrientation","sideOrientation","ClockWiseSideOrientation","CounterClockWiseSideOrientation","extras","targetNames","primitives","glTFNodeIndex","glTFNode","directDescendents","transformNodes","lights","removedRootNodes","metadata","metadataSelector","gltf","removeNoopRootNodes","includeCoordinateSystemConversionNodes","rootNodes","rootNode","cameraMap","camera","shouldExportNode","glTFCamera","PERSPECTIVE_CAMERA","perspective","aspectRatio","getAspectRatio","yfov","fovMode","FOVMODE_VERTICAL_FIXED","fov","znear","minZ","zfar","maxZ","halfWidth","orthoLeft","orthoRight","getRenderWidth","halfHeight","orthoBottom","orthoTop","getRenderHeight","orthographic","xmag","ymag","exportNodes","_getExportNodes","_createNodeMapAndAnimationsAsync","_createSkinsAsync","skinMap","_nodeMap","Log","parent","ComposeToRef","decompose","skeleton","skin","getDescendants","children","descendent","promiseChain","_createNodeAsync","idleGLTFAnimation","weights","skeletons","bones","joints","inverseBindMatrices","boneIndexMap","maxBoneIndex","boneIndex","bone","getIndex","getInvertedAbsoluteTransform","transformNode","getTransformNode","bufferViewOffset","bindMatrixAccessor","inverseBindAccessorIndex","mat","m","cell","_arrayBuffer","_dataView","_byteOffset","_resizeBuffer","newBuffer","copyOldBufferSize","oldUint8Array","setUint8","setUint16","getUint32","getVector3Float32FromRef","vector3","getFloat32","setVector3Float32FromRef","getVector4Float32FromRef","vector4","setVector4Float32FromRef","isNaN","setInt16","setByte","setInt8","GLTFAsync","filePrefix","whenReadyAsync","_PreExportAsync","exportWithoutWaitingForScene","_PostExportAsync","glTFData","GLBAsync","NAME","_wasUsed","uAng","wAng","vAng","uRotationCenter","vRotationCenter","textureTransform","transformIsRequired","uOffset","vOffset","uScale","vScale","KHR_texture_transform","_lights","ShadowLight","light","lightType","getTypeID","LIGHTTYPEID_POINTLIGHT","LIGHTTYPEID_DIRECTIONALLIGHT","LIGHTTYPEID_SPOTLIGHT","Logger","localAxis","direction","yaw","atan2","PI","len","pitch","lightRotationQuaternion","falloffType","FALLOFF_GLTF","intensity","range","Number","MAX_VALUE","babylonSpotLight","angle","spot","outerConeAngle","innerAngle","innerConeAngle","lightReference","parentBabylonNode","getChildren","parentNode","parentTranslation","parentRotation","parentScale","parentMatrix","matrix","OneReadOnly","KHR_lights_punctual","additionalTextures","PBRBaseMaterial","clearCoat","isEnabled","useRoughnessFromMainTexture","textureRoughness","clearCoatTextureRoughnessInfo","clearCoatTextureInfo","isTintEnabled","remapF0OnInterfaceChange","clearCoatNormalTextureInfo","clearcoatFactor","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatNormalTexture","KHR_materials_clearcoat","iridescence","thicknessTexture","iridescenceTextureInfo","iridescenceThicknessTextureInfo","iridescenceFactor","iridescenceIor","indexOfRefraction","iridescenceThicknessMinimum","minimumThickness","iridescenceThicknessMaximum","maximumThickness","iridescenceTexture","iridescenceThicknessTexture","KHR_materials_iridescence","anisotropy","legacy","anisotropyTextureInfo","anisotropyStrength","anisotropyRotation","anisotropyTexture","KHR_materials_anisotropy","PBRMaterial","sheen","sheenColorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","KHR_materials_sheen","unlitMaterial","unlit","StandardMaterial","disableLighting","KHR_materials_unlit","_isExtensionEnabled","iorInfo","ior","KHR_materials_ior","metallicReflectanceTexture","reflectanceTexture","metallicF0Factor","metallicReflectanceColor","equalsFloats","_hasTexturesExtension","specularInfo","specularFactor","specularTexture","specularColorFactor","specularColorTexture","KHR_materials_specular","subSurface","subs","isRefractionEnabled","isTranslucencyEnabled","tintColorAtDistance","POSITIVE_INFINITY","tintColor","volumeInfo","thicknessFactor","attenuationDistance","attenuationColor","KHR_materials_volume","refractionIntensity","refractionIntensityTexture","transmissionFactor","transmissionTexture","KHR_materials_transmission","hasThinInstances","noTranslation","noRotation","noScale","thinInstanceGetWorldMatrices","iwt","iwr","iws","hasAnyInstanceWorldTranslation","hasAnyInstanceWorldRotation","hasAnyInstanceWorldScale","translationBuffer","thinInstanceCount","rotationBuffer","scaleBuffer","equalsWithEpsilon","_buildAccessor","bufferOffset","bv","accessorIndex","normalized","EXT_mesh_gpu_instancing","tempEmissiveStrength","emissiveStrengthInfo","emissiveStrength","newEmissiveFactor","KHR_materials_emissive_strength","__IGLTFExporterExtensionV2","globalObject","BABYLON","GLTF2","Exporter","Extensions"],"sourceRoot":""}